<?xml version="1.0" standalone="no" ?>
<!DOCTYPE doc [
<!ENTITY sqlwCommands SYSTEM "sqlwCommands_tooltip_provider.xml">
]>

<!-- 
==============================================================================================
== BEGIN: README =============================================================================
==============================================================================================
If you add or change content of this file, please send the file or the changed/added entries to goran_schwarz@hotmail.com
If you do, it will be part of the next release...

Note 1: You can use HTML tabs in any of the tags if you think the output will look nicer.
Note 2: Please also use <![CDATA[]]> tag in <Syntax> and the <Example> tag, otherwise the parser will look for tags in the Syntax and Example tags.

Example: <Syntax><![CDATA[<pre>Some syntax description</pre>]]></Syntax>


Description of tags:
=======================================================
<Entry>
    <CmdName>     Used to match the current word against                                               </CmdName>
    <Module>      Just a description of what "section" this belongs to (choose a prober section)       </Module>
    <FromVersion> In what version was this command introduced                                          </FromVersion>   OPTIONAL
    <Description> Descriptive text of what the command does                                            </Description>
    <Syntax>      The Syntax the command can have                                                      </Syntax>
    <Example>     If you want to provide a small example, or several ones...                           </Example>       OPTIONAL
    <SeeAlso>     References to other commands                                                         </SeeAlso>       OPTIONAL
</Entry>



Example:
=======================================================
<Entry>
    <CmdName>selectxxx</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Get information from a table</Description>
    <Syntax><![CDATA[<pre>select [all|distinct] select_list [from]...</pre>]]></Syntax>
    <Example>
<![CDATA[
<UL>
   <LI>
       <B>Example 1</B>: <I>selects all columns from tab1 with <B>no</B> restrictions of the rows returned</I><BR>
       <CODE>select * from tab1</CODE>
   </LI>
   <LI>
       <B>Example 2</B>: <I>selects distinct values of column 'c1' from tab1 with restrictions in rows</I><BR>
       <CODE>select distinct c1 from tab1 where c2 = 'val'</CODE>
   </LI>
   <LI>
       <B>Example 3</B>: <I><FONT COLOR="green">Some other description, but in color green this time</FONT> then black again...</I><BR>
       <CODE>select 'dummy value' as dummyColOne</CODE>
   </LI>
</UL>
]]>
    </Example>
</Entry>

==============================================================================================
== END: README ===============================================================================
==============================================================================================
-->




<!-- ============================================================================================ -->
<!-- == START: ENTRIES ========================================================================== -->
<!-- ============================================================================================ -->
<Entries>

<!-- ============================================================================================ -->
<!-- == include: SQL Window Commands ============================================================ -->
<!-- ============================================================================================ -->
&sqlwCommands;



<!-- ============================================================================================ -->
<!-- == SECTION 1 =============================================================================== -->
<!-- ============================================================================================ -->

<Entry>
    <CmdName>dummy</CmdName>
    <Module>SECTION 1</Module>
    <Description>dummy - just a dummy placeholder</Description>
    <Syntax><![CDATA[<pre>
  DUMMY 1...
    </pre>]]></Syntax>
</Entry>




<!-- ============================================================================================ -->
<!-- == SECTION 2 =============================================================================== -->
<!-- ============================================================================================ -->

<Entry>
    <CmdName>dummy</CmdName>
    <Module>SECTION 2</Module>
    <Description>dummy - just a dummy placeholder</Description>
    <Syntax><![CDATA[<pre>SUBSTRING ( expression ,start , length )</pre>]]></Syntax>
    <Example>
<![CDATA[
SELECT x = SUBSTRING('abcdef', 2, 3);
]]>
    </Example>
</Entry>



<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Aggregate Functions (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>APPROX_COUNT_DISTINCT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the approximate number of unique non-null values in a group.</Description>
    <Syntax><![CDATA[<pre> APPROX_COUNT_DISTINCT ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/approx-count-distinct-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Using APPROX_COUNT_DISTINCT
-- This example returns the approximate number of different order keys from the orders table.
------------------------------------------------------------------------------
SELECT APPROX_COUNT_DISTINCT(O_OrderKey) AS Approx_Distinct_OrderKey
FROM dbo.Orders;

Approx_Distinct_OrderKey
------------------------
15164704


------------------------------------------------------------------------------
-- B. Using APPROX_COUNT_DISTINCT with GROUP BY
-- This example returns the approximate number of different order keys by order status from the orders table.
------------------------------------------------------------------------------
SELECT O_OrderStatus, APPROX_COUNT_DISTINCT(O_OrderKey) AS Approx_Distinct_OrderKey
FROM dbo.Orders
GROUP BY O_OrderStatus
ORDER BY O_OrderStatus;

O_OrderStatus                                                    Approx_Distinct_OrderKey
---------------------------------------------------------------- ------------------------
F                                                                7397838
O                                                                7387803
P                                                                388036
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>AVG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the average of the values in a group. It ignores null values.</Description>
    <Syntax><![CDATA[<pre> AVG ( [ ALL | DISTINCT ] expression ) [ OVER ( [ partition_by_clause ] order_by_clause ) ] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/avg-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Using the SUM and AVG functions for calculations
-- This example calculates the average vacation hours, and the sum of sick leave hours, that the vice presidents of Adventure Works Cycles have used. Each of these aggregate functions produces a single summary value for all the retrieved rows. The example uses the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT AVG(VacationHours)AS 'Average vacation hours',   
    SUM(SickLeaveHours) AS 'Total sick leave hours'  
FROM HumanResources.Employee  
WHERE JobTitle LIKE 'Vice President%';

Average vacation hours       Total sick leave hours
 ----------------------       ----------------------
25                           97
  
(1 row(s) affected)


------------------------------------------------------------------------------
-- B. Using the SUM and AVG functions with a GROUP BY clause
-- When used with a GROUP BY clause, each aggregate function produces a single value covering each group, instead of a single value covering the whole table. The following example produces summary values for each sales territory in the AdventureWorks2012 database. The summary lists the average bonus received by the sales people in each territory, and the sum of year-to-date sales for each territory.
------------------------------------------------------------------------------
SELECT TerritoryID, AVG(Bonus)as 'Average bonus', SUM(SalesYTD) as 'YTD sales'  
FROM Sales.SalesPerson  
GROUP BY TerritoryID;  
GO

TerritoryID Average Bonus         YTD Sales  
----------- --------------------- ---------------------  
NULL        0.00                  1252127.9471  
1           4133.3333             4502152.2674  
2           4100.00               3763178.1787  
3           2500.00               3189418.3662  
4           2775.00               6709904.1666  
5           6700.00               2315185.611  
6           2750.00               4058260.1825  
7           985.00                3121616.3202  
8           75.00                 1827066.7118  
9           5650.00               1421810.9242  
10          5150.00               4116871.2277  
  
(11 row(s) affected)


------------------------------------------------------------------------------
-- C. Using AVG with DISTINCT
-- This statement returns the average list price of products in the AdventureWorks2012 database. Through the use of DISTINCT, the calculation considers only unique values.
------------------------------------------------------------------------------
SELECT AVG(DISTINCT ListPrice)  
FROM Production.Product;

------------------------------
437.4042
  
(1 row(s) affected)


------------------------------------------------------------------------------
-- D. Using AVG without DISTINCT
-- Without DISTINCT, the AVG function finds the average list price of all products in the Product table in the AdventureWorks2012 database, including any duplicate values.
------------------------------------------------------------------------------
SELECT AVG(ListPrice)  
FROM Production.Product;

------------------------------
438.6662
  
(1 row(s) affected)


------------------------------------------------------------------------------
-- E. Using the OVER clause
-- The following example uses the AVG function with the OVER clause, to provide a moving average of yearly sales for each territory in the Sales.SalesPerson table in the AdventureWorks2012 database. The data is partitioned by TerritoryID and logically ordered by SalesYTD. This means that the AVG function is computed for each territory based on the sales year. Note that for TerritoryID 1, there are two rows for sales year 2005, which represent the two sales-people with sales that year. The average sales for these two rows is calculated, and then the third row representing sales for the year 2006 is included in the calculation.
------------------------------------------------------------------------------
SELECT BusinessEntityID, TerritoryID   
   ,DATEPART(yy,ModifiedDate) AS SalesYear  
   ,CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  
   ,CONVERT(varchar(20),AVG(SalesYTD) OVER (PARTITION BY TerritoryID   
                                            ORDER BY DATEPART(yy,ModifiedDate)   
                                           ),1) AS MovingAvg  
   ,CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   
                                            ORDER BY DATEPART(yy,ModifiedDate)   
                                            ),1) AS CumulativeTotal  
FROM Sales.SalesPerson  
WHERE TerritoryID IS NULL OR TerritoryID < 5  
ORDER BY TerritoryID,SalesYear;

BusinessEntityID TerritoryID SalesYear   SalesYTD             MovingAvg            CumulativeTotal  
---------------- ----------- ----------- -------------------- -------------------- --------------------  
274              NULL        2005        559,697.56           559,697.56           559,697.56  
287              NULL        2006        519,905.93           539,801.75           1,079,603.50  
285              NULL        2007        172,524.45           417,375.98           1,252,127.95  
283              1           2005        1,573,012.94         1,462,795.04         2,925,590.07  
280              1           2005        1,352,577.13         1,462,795.04         2,925,590.07  
284              1           2006        1,576,562.20         1,500,717.42         4,502,152.27  
275              2           2005        3,763,178.18         3,763,178.18         3,763,178.18  
277              3           2005        3,189,418.37         3,189,418.37         3,189,418.37  
276              4           2005        4,251,368.55         3,354,952.08         6,709,904.17  
281              4           2005        2,458,535.62         3,354,952.08         6,709,904.17  
  
(10 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CHECKSUM_AGG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the checksum of the values in a group. CHECKSUM_AGG ignores null values. The OVER clause can follow CHECKSUM_AGG.</Description>
    <Syntax><![CDATA[<pre> CHECKSUM_AGG ( [ ALL | DISTINCT ] expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/checksum-agg-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- These examples use CHECKSUM_AGG to detect changes in the Quantity column of the ProductInventory table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
--Get the checksum value before the column value is changed.  

SELECT CHECKSUM_AGG(CAST(Quantity AS int))  
FROM Production.ProductInventory;  
GO

------------------------  
262


UPDATE Production.ProductInventory   
SET Quantity=125  
WHERE Quantity=100;  
GO  

--Get the checksum of the modified column.  
SELECT CHECKSUM_AGG(CAST(Quantity AS int))  
FROM Production.ProductInventory;

------------------------  
287
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COUNT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the number of items found in a group. COUNT operates like the COUNT_BIG function. These functions differ only in the data types of their return values. COUNT always returns an int data type value. COUNT_BIG always returns a bigint data type value.</Description>
    <Syntax><![CDATA[<pre> COUNT ( [ ALL | DISTINCT ]  { expression | * } ) OVER ( [ <partition_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/count-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Using COUNT and DISTINCT
-- This example returns the number of different titles that an Adventure Works Cycles employee can hold.
------------------------------------------------------------------------------
SELECT COUNT(DISTINCT Title)  
FROM HumanResources.Employee;  
GO

-----------
67  
(1 row(s) affected)


------------------------------------------------------------------------------
-- B. Using COUNT(*)
-- This example returns the total number of Adventure Works Cycles employees.
------------------------------------------------------------------------------
SELECT COUNT(*)  
FROM HumanResources.Employee;  
GO

-----------
290


------------------------------------------------------------------------------
-- C. Using COUNT(*) with other aggregates
-- This example shows that COUNT(*) works with other aggregate functions in the SELECT list. The example uses the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT COUNT(*), AVG(Bonus)  
FROM Sales.SalesPerson  
WHERE SalesQuota > 25000;  
GO

----------- ---------------------
14            3472.1428
  
(1 row(s) affected)


------------------------------------------------------------------------------
-- D. Using the OVER clause
-- This example uses the MIN, MAX, AVG and COUNT functions with the OVER clause, to return aggregated values for each department in the AdventureWorks2012 database HumanResources.Department table.
------------------------------------------------------------------------------
SELECT DISTINCT Name  
       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS MinSalary  
       , MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS MaxSalary  
       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS AvgSalary  
       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.DepartmentID) AS EmployeesPerDept  
FROM HumanResources.EmployeePayHistory AS eph  
JOIN HumanResources.EmployeeDepartmentHistory AS edh  
     ON eph.BusinessEntityID = edh.BusinessEntityID  
JOIN HumanResources.Department AS d  
ON d.DepartmentID = edh.DepartmentID
WHERE edh.EndDate IS NULL  
ORDER BY Name;

Name                          MinSalary             MaxSalary             AvgSalary             EmployeesPerDept  
----------------------------- --------------------- --------------------- --------------------- ----------------  
Document Control              10.25                 17.7885               14.3884               5  
Engineering                   32.6923               63.4615               40.1442               6  
Executive                     39.06                 125.50                68.3034               4  
Facilities and Maintenance    9.25                  24.0385               13.0316               7  
Finance                       13.4615               43.2692               23.935                10  
Human Resources               13.9423               27.1394               18.0248               6  
Information Services          27.4038               50.4808               34.1586               10  
Marketing                     13.4615               37.50                 18.4318               11  
Production                    6.50                  84.1346               13.5537               195  
Production Control            8.62                  24.5192               16.7746               8  
Purchasing                    9.86                  30.00                 18.0202               14  
Quality Assurance             10.5769               28.8462               15.4647               6  
Research and Development      40.8654               50.4808               43.6731               4  
Sales                         23.0769               72.1154               29.9719               18  
Shipping and Receiving        9.00                  19.2308               10.8718               6  
Tool Design                   8.62                  29.8462               23.5054               6  
  
(16 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COUNT_BIG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the number of items found in a group. COUNT_BIG operates like the COUNT function. These functions differ only in the data types of their return values. COUNT_BIG always returns a bigint data type value. COUNT always returns an int data type value.</Description>
    <Syntax><![CDATA[<pre>COUNT_BIG ( [ ALL | DISTINCT ] { expression | * } ) OVER ( [ <partition_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/count-big-transact-sql</SourceURL>
    <Example><![CDATA[<pre> see count() </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GROUPING</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Indicates whether a specified column expression in a GROUP BY list is aggregated or not. GROUPING returns 1 for aggregated or 0 for not aggregated in the result set. GROUPING can be used only in the SELECT &lt;select&gt; list, HAVING, and ORDER BY clauses when GROUP BY is specified.</Description>
    <Syntax><![CDATA[<pre> GROUPING ( <column_expression> ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/grouping-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- The following example groups SalesQuota and aggregates SaleYTD amounts in the AdventureWorks2012 database. The GROUPING function is applied to the SalesQuota column.
------------------------------------------------------------------------------
SELECT SalesQuota, SUM(SalesYTD) 'TotalSalesYTD', GROUPING(SalesQuota) AS 'Grouping'  
FROM Sales.SalesPerson  
GROUP BY SalesQuota WITH ROLLUP;  
GO

-- The result set shows two null values under SalesQuota. The first NULL represents the group of null values from this column in the table. The second NULL is in the summary row added by the ROLLUP operation. The summary row shows the TotalSalesYTD amounts for all SalesQuota groups and is indicated by 1 in the Grouping column.

SalesQuota     TotalSalesYTD       Grouping  
------------   -----------------   --------  
NULL           1533087.5999          0  
250000.00      33461260.59           0  
300000.00      9299677.9445          0  
NULL           44294026.1344         1  

(4 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GROUPING_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Is a function that computes the level of grouping. GROUPING_ID can be used only in the SELECT &lt;select&gt; list, HAVING, or ORDER BY clauses when GROUP BY is specified.</Description>
    <Syntax><![CDATA[<pre> GROUPING_ID ( <column_expression>[ ,...n ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/grouping-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Using GROUPING_ID to identify grouping levels
-- The following example returns the count of employees by Name and Title, Name, and company total in the AdventureWorks2012 database. GROUPING_ID() is used to create a value for each row in the Title column that identifies its level of aggregation.
------------------------------------------------------------------------------
SELECT D.Name  
    ,CASE   
    WHEN GROUPING_ID(D.Name, E.JobTitle) = 0 THEN E.JobTitle  
    WHEN GROUPING_ID(D.Name, E.JobTitle) = 1 THEN N'Total: ' + D.Name   
    WHEN GROUPING_ID(D.Name, E.JobTitle) = 3 THEN N'Company Total:'  
        ELSE N'Unknown'  
    END AS N'Job Title'  
    ,COUNT(E.BusinessEntityID) AS N'Employee Count'  
FROM HumanResources.Employee E  
    INNER JOIN HumanResources.EmployeeDepartmentHistory DH  
        ON E.BusinessEntityID = DH.BusinessEntityID  
    INNER JOIN HumanResources.Department D  
        ON D.DepartmentID = DH.DepartmentID       
WHERE DH.EndDate IS NULL  
    AND D.DepartmentID IN (12,14)  
GROUP BY ROLLUP(D.Name, E.JobTitle);

------------------------------------------------------------------------------
-- B. Using GROUPING_ID to filter a result set
-- Simple Example
-- In the following code, to return only the rows that have a count of employees by title, remove the comment characters from HAVING GROUPING_ID(D.Name, E.JobTitle); = 0 in the AdventureWorks2012 database. To return only rows with a count of employees by department, remove the comment characters from HAVING GROUPING_ID(D.Name, E.JobTitle) = 1;.
------------------------------------------------------------------------------
SELECT D.Name  
    ,E.JobTitle  
    ,GROUPING_ID(D.Name, E.JobTitle) AS 'Grouping Level'  
    ,COUNT(E.BusinessEntityID) AS N'Employee Count'  
FROM HumanResources.Employee AS E  
    INNER JOIN HumanResources.EmployeeDepartmentHistory AS DH  
        ON E.BusinessEntityID = DH.BusinessEntityID  
    INNER JOIN HumanResources.Department AS D  
        ON D.DepartmentID = DH.DepartmentID       
WHERE DH.EndDate IS NULL  
    AND D.DepartmentID IN (12,14)  
GROUP BY ROLLUP(D.Name, E.JobTitle)  
--HAVING GROUPING_ID(D.Name, E.JobTitle) = 0; --All titles  
--HAVING GROUPING_ID(D.Name, E.JobTitle) = 1; --Group by Name;

</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>MAX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the maximum value in the expression.</Description>
    <Syntax><![CDATA[<pre>MAX ([ ALL | DISTINCT ] expression) OVER ( [ <partition_by_clause> ] [ <order_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/max-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Simple example
-- The following example returns the highest (maximum) tax rate in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT MAX(TaxRate)  
FROM Sales.SalesTaxRate;  
GO

-------------------  
19.60  
Warning, null value eliminated from aggregate.  
 
(1 row(s) affected)



------------------------------------------------------------------------------
-- B. Using the OVER clause
-- The following example uses the MIN, MAX, AVG, and COUNT functions with the OVER clause to provide aggregated values for each department in the HumanResources.Department table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT DISTINCT Name  
       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS MinSalary  
       , MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS MaxSalary  
       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS AvgSalary  
       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.DepartmentID) AS EmployeesPerDept  
FROM HumanResources.EmployeePayHistory AS eph  
JOIN HumanResources.EmployeeDepartmentHistory AS edh  
     ON eph.BusinessEntityID = edh.BusinessEntityID  
JOIN HumanResources.Department AS d  
 ON d.DepartmentID = edh.DepartmentID  
WHERE edh.EndDate IS NULL  
ORDER BY Name;

Name                          MinSalary             MaxSalary             AvgSalary             EmployeesPerDept  
----------------------------- --------------------- --------------------- --------------------- ----------------  
Document Control              10.25                 17.7885               14.3884               5  
Engineering                   32.6923               63.4615               40.1442               6  
Executive                     39.06                 125.50                68.3034               4  
Facilities and Maintenance    9.25                  24.0385               13.0316               7  
Finance                       13.4615               43.2692               23.935                10  
Human Resources               13.9423               27.1394               18.0248               6  
Information Services          27.4038               50.4808               34.1586               10  
Marketing                     13.4615               37.50                 18.4318               11  
Production                    6.50                  84.1346               13.5537               195  
Production Control            8.62                  24.5192               16.7746               8  
Purchasing                    9.86                  30.00                 18.0202               14  
Quality Assurance             10.5769               28.8462               15.4647               6  
Research and Development      40.8654               50.4808               43.6731               4  
Sales                         23.0769               72.1154               29.9719               18  
Shipping and Receiving        9.00                  19.2308               10.8718               6  
Tool Design                   8.62                  29.8462               23.5054               6  
  
 (16 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>MIN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the minimum value in the expression. May be followed by the OVER clause.</Description>
    <Syntax><![CDATA[<pre>MIN ( [ ALL | DISTINCT ] expression ) OVER ( [ <partition_by_clause> ] [ <order_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/min-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Simple example
-- The following example returns the lowest (minimum) tax rate. The example uses the AdventureWorks2012 database
------------------------------------------------------------------------------
SELECT MIN(TaxRate)  
FROM Sales.SalesTaxRate;  
GO

-------------------
5.00
(1 row(s) affected)



------------------------------------------------------------------------------
-- B. Using the OVER clause
-- The following example uses the MIN, MAX, AVG and COUNT functions with the OVER clause to provide aggregated values for each department in the HumanResources.Department table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT DISTINCT Name  
       , MIN(Rate) OVER (PARTITION BY edh.DepartmentID) AS MinSalary  
       , MAX(Rate) OVER (PARTITION BY edh.DepartmentID) AS MaxSalary  
       , AVG(Rate) OVER (PARTITION BY edh.DepartmentID) AS AvgSalary  
       ,COUNT(edh.BusinessEntityID) OVER (PARTITION BY edh.DepartmentID) AS EmployeesPerDept  
FROM HumanResources.EmployeePayHistory AS eph  
JOIN HumanResources.EmployeeDepartmentHistory AS edh  
     ON eph.BusinessEntityID = edh.BusinessEntityID  
JOIN HumanResources.Department AS d  
 ON d.DepartmentID = edh.DepartmentID  
WHERE edh.EndDate IS NULL  
ORDER BY Name;

Name                          MinSalary             MaxSalary             AvgSalary             EmployeesPerDept  
----------------------------- --------------------- --------------------- --------------------- ----------------  
Document Control              10.25                 17.7885               14.3884               5  
Engineering                   32.6923               63.4615               40.1442               6  
Executive                     39.06                 125.50                68.3034               4  
Facilities and Maintenance    9.25                  24.0385               13.0316               7  
Finance                       13.4615               43.2692               23.935                10  
Human Resources               13.9423               27.1394               18.0248               6  
Information Services          27.4038               50.4808               34.1586               10  
Marketing                     13.4615               37.50                 18.4318               11  
Production                    6.50                  84.1346               13.5537               195  
Production Control            8.62                  24.5192               16.7746               8  
Purchasing                    9.86                  30.00                 18.0202               14  
Quality Assurance             10.5769               28.8462               15.4647               6  
Research and Development      40.8654               50.4808               43.6731               4  
Sales                         23.0769               72.1154               29.9719               18  
Shipping and Receiving        9.00                  19.2308               10.8718               6  
Tool Design                   8.62                  29.8462               23.5054               6  
  
 (16 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STDEV</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the statistical standard deviation of all values in the specified expression.</Description>
    <Syntax><![CDATA[<pre>STDEV ([ ALL | DISTINCT ] expression) OVER ( [ partition_by_clause ] order_by_clause) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/stdev-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- The following example returns the standard deviation for all bonus values in the SalesPerson table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT STDEV(Bonus)  
FROM Sales.SalesPerson;  
GO


------------------------------------------------------------------------------
-- C. Using STDEV with OVER
-- The following example returns the standard deviation of the sales quota values for each quarter in a calendar year. Notice that the ORDER BY in the OVER clause orders the STDEV and the ORDER BY of the SELECT statement orders the result set.
------------------------------------------------------------------------------
-- Uses AdventureWorks  
  
SELECT CalendarYear AS Year, CalendarQuarter AS Quarter, SalesAmountQuota AS SalesQuota,  
       STDEV(SalesAmountQuota) OVER (ORDER BY CalendarYear, CalendarQuarter) AS StdDeviation  
FROM dbo.FactSalesQuota  
WHERE EmployeeKey = 272 AND CalendarYear = 2002  
ORDER BY CalendarQuarter;

Year  Quarter  SalesQuota              StdDeviation
----  -------  ----------------------  -------------------
2002  1         91000.0000             null
2002  2        140000.0000             34648.23
2002  3         70000.0000             35921.21
2002  4        154000.0000             39752.36
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STDEVP</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the statistical standard deviation for the population for all values in the specified expression.</Description>
    <Syntax><![CDATA[<pre>STDEVP ([ ALL | DISTINCT ] expression) OVER ( [ partition_by_clause ] order_by_clause) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/stdevp-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A: Using STDEVP
-- The following example returns the standard deviation for the population for all bonus values in the SalesPerson table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT STDEVP(Bonus)  
FROM Sales.SalesPerson;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the sum of all the values, or only the DISTINCT values, in the expression. SUM can be used with numeric columns only. Null values are ignored.</Description>
    <Syntax><![CDATA[<pre>SUM ([ ALL | DISTINCT ] expression) OVER ( [ partition_by_clause ] order_by_clause) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sum-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Using SUM to return summary data
-- The following examples show using the SUM function to return summary data in the AdventureWorks2012 database
------------------------------------------------------------------------------
SELECT Color, SUM(ListPrice), SUM(StandardCost)  
FROM Production.Product  
WHERE Color IS NOT NULL   
    AND ListPrice != 0.00   
    AND Name LIKE 'Mountain%'  
GROUP BY Color  
ORDER BY Color;  
GO

Color
--------------- --------------------- ---------------------
Black           27404.84              5214.9616
Silver          26462.84              14665.6792
White           19.00                 6.7926

(3 row(s) affected)


------------------------------------------------------------------------------
-- B. Using the OVER clause
-- The following example uses the SUM function with the OVER clause to provide a cumulative total of yearly sales for each territory in the Sales.SalesPerson table in the AdventureWorks2012 database. The data is partitioned by TerritoryID and logically ordered by SalesYTD. This means that the SUM function is computed for each territory based on the sales year. Notice that for TerritoryID 1, there are two rows for sales year 2005 representing the two sales people with sales that year. The cumulative sales total for these two rows is computed and then the third row representing sales for the year 2006 is included in the computation.
------------------------------------------------------------------------------
SELECT BusinessEntityID, TerritoryID   
   ,DATEPART(yy,ModifiedDate) AS SalesYear  
   ,CONVERT(varchar(20),SalesYTD,1) AS  SalesYTD  
   ,CONVERT(varchar(20),AVG(SalesYTD) OVER (PARTITION BY TerritoryID   
                                            ORDER BY DATEPART(yy,ModifiedDate)   
                                           ),1) AS MovingAvg  
   ,CONVERT(varchar(20),SUM(SalesYTD) OVER (PARTITION BY TerritoryID   
                                            ORDER BY DATEPART(yy,ModifiedDate)   
                                            ),1) AS CumulativeTotal  
FROM Sales.SalesPerson  
WHERE TerritoryID IS NULL OR TerritoryID < 5  
ORDER BY TerritoryID,SalesYear;

BusinessEntityID TerritoryID SalesYear   SalesYTD             MovingAvg            CumulativeTotal  
---------------- ----------- ----------- -------------------- -------------------- --------------------  
274              NULL        2005        559,697.56           559,697.56           559,697.56  
287              NULL        2006        519,905.93           539,801.75           1,079,603.50  
285              NULL        2007        172,524.45           417,375.98           1,252,127.95  
283              1           2005        1,573,012.94         1,462,795.04         2,925,590.07  
280              1           2005        1,352,577.13         1,462,795.04         2,925,590.07  
284              1           2006        1,576,562.20         1,500,717.42         4,502,152.27  
275              2           2005        3,763,178.18         3,763,178.18         3,763,178.18  
277              3           2005        3,189,418.37         3,189,418.37         3,189,418.37  
276              4           2005        4,251,368.55         3,354,952.08         6,709,904.17  
281              4           2005        2,458,535.62         3,354,952.08         6,709,904.17  
  
(10 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>VAR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the statistical variance of all values in the specified expression. May be followed by the OVER clause.</Description>
    <Syntax><![CDATA[<pre>VAR ([ ALL | DISTINCT ] expression) OVER ( [ partition_by_clause ] order_by_clause) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/var-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A: Using VAR
-- The following example returns the variance for all bonus values in the SalesPerson table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT VAR(Bonus)  
FROM Sales.SalesPerson;  
GO

------------------------------------------------------------------------------
-- C. Using VAR with OVER
-- The following example returns the statistical variance of the sales quota values for each quarter in a calendar year. Notice that the ORDER BY in the OVER clause orders the statistical variance and the ORDER BY of the SELECT statement orders the result set.
------------------------------------------------------------------------------
-- Uses AdventureWorks  
  
SELECT CalendarYear AS Year, CalendarQuarter AS Quarter, SalesAmountQuota AS SalesQuota,  
       VAR(SalesAmountQuota) OVER (ORDER BY CalendarYear, CalendarQuarter) AS Variance  
FROM dbo.FactSalesQuota  
WHERE EmployeeKey = 272 AND CalendarYear = 2002  
ORDER BY CalendarQuarter;

Year  Quarter  SalesQuota              Variance
----  -------  ----------------------  -------------------
2002  1         91000.0000             null
2002  2        140000.0000             1200500000.00
2002  3         70000.0000             1290333333.33
2002  4        154000.0000             1580250000.00
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>VARP</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the statistical variance for the population for all values in the specified expression.</Description>
    <Syntax><![CDATA[<pre>VARP ([ ALL | DISTINCT ] expression) OVER ( [ partition_by_clause ] order_by_clause) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/varp-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A: Using VARP
The following example returns the variance for the population for all bonus values in the SalesPerson table in the AdventureWorks2012 database.
------------------------------------------------------------------------------
SELECT VARP(Bonus)  
FROM Sales.SalesPerson;  
GO
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Analytic Functions (Transact-SQL) =========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>CUME_DIST</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>For SQL Server, this function calculates the cumulative distribution of a value within a group of values. In other words, CUME_DIST calculates the relative position of a specified value in a group of values. Assuming ascending ordering, the CUME_DIST of a value in row r is defined as the number of rows with values less than or equal to that value in row r, divided by the number of rows evaluated in the partition or query result set. CUME_DIST is similar to the PERCENT_RANK function.</Description>
    <Syntax><![CDATA[<pre> CUME_DIST( ) OVER ( [ partition_by_clause ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cume-dist-transact-sql?view=sql-server-ver15</SourceURL>
    <Example><![CDATA[<pre> 
-- This example uses the CUME_DIST function to calculate the salary percentile for each employee within a given department. CUME_DIST returns a value that represents the percent of employees with a salary less than or equal to the current employee in the same department. The PERCENT_RANK function calculates the percent rank of the employee's salary within a department. To partition the result set rows by department, the example specifies the partition_by_clause value. The ORDER BY clause of the OVER clause logically orders the rows in each partition. The ORDER BY clause of the SELECT statement determines the display order of the result set.
USE AdventureWorks2012;  
GO  
SELECT Department, LastName, Rate,   
       CUME_DIST () OVER (PARTITION BY Department ORDER BY Rate) AS CumeDist,   
       PERCENT_RANK() OVER (PARTITION BY Department ORDER BY Rate ) AS PctRank  
FROM HumanResources.vEmployeeDepartmentHistory AS edh  
    INNER JOIN HumanResources.EmployeePayHistory AS e    
    ON e.BusinessEntityID = edh.BusinessEntityID  
WHERE Department IN (N'Information Services',N'Document Control')   
ORDER BY Department, Rate DESC;

Here is the result set.
Department             LastName               Rate                  CumeDist               PctRank  
---------------------- ---------------------- --------------------- ---------------------- ----------------------  
Document Control       Arifin                 17.7885               1                      1  
Document Control       Norred                 16.8269               0.8                    0.5  
Document Control       Kharatishvili          16.8269               0.8                    0.5  
Document Control       Chai                   10.25                 0.4                    0  
Document Control       Berge                  10.25                 0.4                    0  
Information Services   Trenary                50.4808               1                      1  
Information Services   Conroy                 39.6635               0.9                    0.888888888888889  
Information Services   Ajenstat               38.4615               0.8                    0.666666666666667  
Information Services   Wilson                 38.4615               0.8                    0.666666666666667  
Information Services   Sharma                 32.4519               0.6                    0.444444444444444  
Information Services   Connelly               32.4519               0.6                    0.444444444444444  
Information Services   Berg                   27.4038               0.4                    0  
Information Services   Meyyappan              27.4038               0.4                    0  
Information Services   Bacon                  27.4038               0.4                    0  
Information Services   Bueno                  27.4038               0.4                    0  
(15 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FIRST_VALUE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the first value in an ordered set of values in SQL Server 2019 (15.x).</Description>
    <Syntax><![CDATA[<pre> FIRST_VALUE ( [scalar_expression ] ) OVER ( [ partition_by_clause ] order_by_clause [ rows_range_clause ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/first-value-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
----------------------------------------------------------------------------------
-- A. Using FIRST_VALUE over a query result set
-- The following example uses FIRST_VALUE to return the name of the product that is the least expensive in a given product category.
----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT Name, ListPrice,   
       FIRST_VALUE(Name) OVER (ORDER BY ListPrice ASC) AS LeastExpensive   
FROM Production.Product  
WHERE ProductSubcategoryID = 37;

Name                    ListPrice             LeastExpensive  
----------------------- --------------------- --------------------  
Patch Kit/8 Patches     2.29                  Patch Kit/8 Patches  
Road Tire Tube          3.99                  Patch Kit/8 Patches  
Touring Tire Tube       4.99                  Patch Kit/8 Patches  
Mountain Tire Tube      4.99                  Patch Kit/8 Patches  
LL Road Tire            21.49                 Patch Kit/8 Patches  
ML Road Tire            24.99                 Patch Kit/8 Patches  
LL Mountain Tire        24.99                 Patch Kit/8 Patches  
Touring Tire            28.99                 Patch Kit/8 Patches  
ML Mountain Tire        29.99                 Patch Kit/8 Patches  
HL Road Tire            32.60                 Patch Kit/8 Patches  
HL Mountain Tire        35.00                 Patch Kit/8 Patches


----------------------------------------------------------------------------------
-- B. Using FIRST_VALUE over partitions
-- The following example uses FIRST_VALUE to return the employee with the fewest number of vacation hours compared to other employees with the same job title. The PARTITION BY clause partitions the employees by job title and the FIRST_VALUE function is applied to each partition independently. The ORDER BY clause specified in the OVER clause determines the logical order in which the FIRST_VALUE function is applied to the rows in each partition. The ROWS UNBOUNDED PRECEDING clause specifies the starting point of the window is the first row of each partition.
----------------------------------------------------------------------------------
USE AdventureWorks2012;   
GO  
SELECT JobTitle, LastName, VacationHours,   
       FIRST_VALUE(LastName) OVER (PARTITION BY JobTitle   
                                   ORDER BY VacationHours ASC  
                                   ROWS UNBOUNDED PRECEDING  
                                  ) AS FewestVacationHours  
FROM HumanResources.Employee AS e  
INNER JOIN Person.Person AS p   
    ON e.BusinessEntityID = p.BusinessEntityID  
ORDER BY JobTitle;

JobTitle                            LastName                  VacationHours FewestVacationHours  
----------------------------------- ------------------------- ------------- -------------------  
Accountant                          Moreland                  58            Moreland  
Accountant                          Seamans                   59            Moreland  
Accounts Manager                    Liu                       57            Liu  
Accounts Payable Specialist         Tomic                     63            Tomic  
Accounts Payable Specialist         Sheperdigian              64            Tomic  
Accounts Receivable Specialist      Poe                       60            Poe  
Accounts Receivable Specialist      Spoon                     61            Poe  
Accounts Receivable Specialist      Walton                    62            Poe
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LAG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Accesses data from a previous row in the same result set without the use of a self-join starting with SQL Server 2012 (11.x). LAG provides access to a row at a given physical offset that comes before the current row. Use this analytic function in a SELECT statement to compare values in the current row with values in a previous row.</Description>
    <Syntax><![CDATA[<pre> LAG (scalar_expression [,offset] [,default]) OVER ( [ partition_by_clause ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/lag-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
----------------------------------------------------------------------------------
-- A. Compare values between years
-- The following example uses the LAG function to return the difference in sales quotas for a specific employee over previous years. Notice that because there is no lag value available for the first row, the default of zero (0) is returned.
----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT BusinessEntityID, YEAR(QuotaDate) AS SalesYear, SalesQuota AS CurrentQuota,   
       LAG(SalesQuota, 1,0) OVER (ORDER BY YEAR(QuotaDate)) AS PreviousQuota  
FROM Sales.SalesPersonQuotaHistory  
WHERE BusinessEntityID = 275 and YEAR(QuotaDate) IN ('2005','2006');

BusinessEntityID SalesYear   CurrentQuota          PreviousQuota  
---------------- ----------- --------------------- ---------------------  
275              2005        367000.00             0.00  
275              2005        556000.00             367000.00  
275              2006        502000.00             556000.00  
275              2006        550000.00             502000.00  
275              2006        1429000.00            550000.00  
275              2006        1324000.00            1429000.00


----------------------------------------------------------------------------------
-- B. Compare values within partitions
-- The following example uses the LAG function to compare year-to-date sales between employees. The PARTITION BY clause is specified to divide the rows in the result set by sales territory. The LAG function is applied to each partition separately and computation restarts for each partition. The ORDER BY clause in the OVER clause orders the rows in each partition. The ORDER BY clause in the SELECT statement sorts the rows in the whole result set. Notice that because there is no lag value available for the first row of each partition, the default of zero (0) is returned.
----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT TerritoryName, BusinessEntityID, SalesYTD,   
       LAG (SalesYTD, 1, 0) OVER (PARTITION BY TerritoryName ORDER BY SalesYTD DESC) AS PrevRepSales  
FROM Sales.vSalesPerson  
WHERE TerritoryName IN (N'Northwest', N'Canada')   
ORDER BY TerritoryName;

TerritoryName            BusinessEntityID SalesYTD              PrevRepSales  
-----------------------  ---------------- --------------------- ---------------------  
Canada                   282              2604540.7172          0.00  
Canada                   278              1453719.4653          2604540.7172  
Northwest                284              1576562.1966          0.00  
Northwest                283              1573012.9383          1576562.1966  
Northwest                280              1352577.1325          1573012.9383


----------------------------------------------------------------------------------
-- C. Specifying arbitrary expressions
-- The following example demonstrates specifying a variety of arbitrary expressions in the LAG function syntax.
----------------------------------------------------------------------------------
CREATE TABLE T (a int, b int, c int);   
GO  
INSERT INTO T VALUES (1, 1, -3), (2, 2, 4), (3, 1, NULL), (4, 3, 1), (5, 2, NULL), (6, 1, 5);   
  
SELECT b, c,   
    LAG(2*c, b*(SELECT MIN(b) FROM T), -c/2.0) OVER (ORDER BY a) AS i  
FROM T;

b           c           i  
----------- ----------- -----------  
1           -3          1  
2           4           -2  
1           NULL        8  
3           1           -6  
2           NULL        NULL  
1           5           NULL
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LAST_VALUE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the last value in an ordered set of values.</Description>
    <Syntax><![CDATA[<pre> LAST_VALUE ( [ scalar_expression ] ) OVER ( [ partition_by_clause ] order_by_clause rows_range_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/last-value-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------
-- A. Using LAST_VALUE over partitions
-- The following example returns the hire date of the last employee in each department for the given salary (Rate). The PARTITION BY clause partitions the employees by department and the LAST_VALUE function is applied to each partition independently. The ORDER BY clause specified in the OVER clause determines the logical order in which the LAST_VALUE function is applied to the rows in each partition.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT Department, LastName, Rate, HireDate,   
    LAST_VALUE(HireDate) OVER (PARTITION BY Department ORDER BY Rate) AS LastValue  
FROM HumanResources.vEmployeeDepartmentHistory AS edh  
INNER JOIN HumanResources.EmployeePayHistory AS eph    
    ON eph.BusinessEntityID = edh.BusinessEntityID  
INNER JOIN HumanResources.Employee AS e  
    ON e.BusinessEntityID = edh.BusinessEntityID  
WHERE Department IN (N'Information Services',N'Document Control');

Department                  LastName                Rate         HireDate     LastValue  
--------------------------- ----------------------- ------------ ----------   ----------  
Document Control            Chai                    10.25        2003-02-23   2003-03-13  
Document Control            Berge                   10.25        2003-03-13   2003-03-13  
Document Control            Norred                  16.8269      2003-04-07   2003-01-17  
Document Control            Kharatishvili           16.8269      2003-01-17   2003-01-17  
Document Control            Arifin                  17.7885      2003-02-05   2003-02-05  
Information Services        Berg                    27.4038      2003-03-20   2003-01-24  
Information Services        Meyyappan               27.4038      2003-03-07   2003-01-24  
Information Services        Bacon                   27.4038      2003-02-12   2003-01-24  
Information Services        Bueno                   27.4038      2003-01-24   2003-01-24  
Information Services        Sharma                  32.4519      2003-01-05   2003-03-27  
Information Services        Connelly                32.4519      2003-03-27   2003-03-27  
Information Services        Ajenstat                38.4615      2003-02-18   2003-02-23  
Information Services        Wilson                  38.4615      2003-02-23   2003-02-23  
Information Services        Conroy                  39.6635      2003-03-08   2003-03-08  
Information Services        Trenary                 50.4808      2003-01-12   2003-01-12


-----------------------------------------------------------------------------------
-- B. Using FIRST_VALUE and LAST_VALUE in a computed expression
-- The following example uses the FIRST_VALUE and LAST_VALUE functions in computed expressions to show the difference between the sales quota value for the current quarter and the first and last quarter of the year respectively for a given number of employees. The FIRST_VALUE function returns the sales quota value for the first quarter of the year, and subtracts it from the sales quota value for the current quarter. It is returned in the derived column entitled DifferenceFromFirstQuarter. For the first quarter of a year, the value of the DifferenceFromFirstQuarter column is 0. The LAST_VALUE function returns the sales quota value for the last quarter of the year, and subtracts it from the sales quota value for the current quarter. It is returned in the derived column entitled DifferenceFromLastQuarter. For the last quarter of a year, the value of the DifferenceFromLastQuarter column is 0.
-- The clause "RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING" is required in this example for the non-zero values to be returned in the DifferenceFromLastQuarter column, as shown below. The default range is "RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW". In this example, using that default range (or not including a range, resulting in the default being used) would result in zeroes being returned in the DifferenceFromLastQuarter column. For more information, see OVER Clause (Transact-SQL).
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
SELECT BusinessEntityID, DATEPART(QUARTER,QuotaDate)AS Quarter, YEAR(QuotaDate) AS SalesYear,   
    SalesQuota AS QuotaThisQuarter,   
    SalesQuota - FIRST_VALUE(SalesQuota)   
        OVER (PARTITION BY BusinessEntityID, YEAR(QuotaDate)   
              ORDER BY DATEPART(QUARTER,QuotaDate) ) AS DifferenceFromFirstQuarter,   
    SalesQuota - LAST_VALUE(SalesQuota)   
        OVER (PARTITION BY BusinessEntityID, YEAR(QuotaDate)   
              ORDER BY DATEPART(QUARTER,QuotaDate)   
              RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) AS DifferenceFromLastQuarter   
FROM Sales.SalesPersonQuotaHistory   
WHERE YEAR(QuotaDate) > 2005   
AND BusinessEntityID BETWEEN 274 AND 275   
ORDER BY BusinessEntityID, SalesYear, Quarter;

BusinessEntityID Quarter     SalesYear   QuotaThisQuarter      DifferenceFromFirstQuarter DifferenceFromLastQuarter  
---------------- ----------- ----------- --------------------- --------------------------- -----------------------  
274              1           2006        91000.00              0.00                        -63000.00  
274              2           2006        140000.00             49000.00                    -14000.00  
274              3           2006        70000.00              -21000.00                   -84000.00  
274              4           2006        154000.00             63000.00                    0.00  
274              1           2007        107000.00             0.00                        -9000.00  
274              2           2007        58000.00              -49000.00                   -58000.00  
274              3           2007        263000.00             156000.00                   147000.00  
274              4           2007        116000.00             9000.00                     0.00  
274              1           2008        84000.00              0.00                        -103000.00  
274              2           2008        187000.00             103000.00                   0.00  
275              1           2006        502000.00             0.00                        -822000.00  
275              2           2006        550000.00             48000.00                    -774000.00  
275              3           2006        1429000.00            927000.00                   105000.00  
275              4           2006        1324000.00            822000.00                   0.00  
275              1           2007        729000.00             0.00                        -489000.00  
275              2           2007        1194000.00            465000.00                   -24000.00  
275              3           2007        1575000.00            846000.00                   357000.00  
275              4           2007        1218000.00            489000.00                   0.00  
275              1           2008        849000.00             0.00                        -20000.00  
275              2           2008        869000.00             20000.00                    0.00  
  
(20 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LEAD</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Accesses data from a subsequent row in the same result set without the use of a self-join starting with SQL Server 2012 (11.x). LEAD provides access to a row at a given physical offset that follows the current row. Use this analytic function in a SELECT statement to compare values in the current row with values in a following row.</Description>
    <Syntax><![CDATA[<pre> LEAD ( scalar_expression [ ,offset ] , [ default ] ) OVER ( [ partition_by_clause ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/lead-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------
-- A. Compare values between years
-- The query uses the LEAD function to return the difference in sales quotas for a specific employee over subsequent years. Notice that because there is no lead value available for the last row, the default of zero (0) is returned.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT BusinessEntityID, YEAR(QuotaDate) AS SalesYear, SalesQuota AS CurrentQuota,   
    LEAD(SalesQuota, 1,0) OVER (ORDER BY YEAR(QuotaDate)) AS NextQuota  
FROM Sales.SalesPersonQuotaHistory  
WHERE BusinessEntityID = 275 and YEAR(QuotaDate) IN ('2005','2006');

BusinessEntityID SalesYear   CurrentQuota          NextQuota  
---------------- ----------- --------------------- ---------------------  
275              2005        367000.00             556000.00  
275              2005        556000.00             502000.00  
275              2006        502000.00             550000.00  
275              2006        550000.00             1429000.00  
275              2006        1429000.00            1324000.00  
275              2006        1324000.00            0.00



-----------------------------------------------------------------------------------
-- B. Compare values within partitions
-- The following example uses the LEAD function to compare year-to-date sales between employees. The PARTITION BY clause is specified to partition the rows in the result set by sales territory. The LEAD function is applied to each partition separately and computation restarts for each partition. The ORDER BY clause specified in the OVER clause orders the rows in each partition before the function is applied. The ORDER BY clause in the SELECT statement orders the rows in the whole result set. Notice that because there is no lead value available for the last row of each partition, the default of zero (0) is returned.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT TerritoryName, BusinessEntityID, SalesYTD,   
       LEAD (SalesYTD, 1, 0) OVER (PARTITION BY TerritoryName ORDER BY SalesYTD DESC) AS NextRepSales  
FROM Sales.vSalesPerson  
WHERE TerritoryName IN (N'Northwest', N'Canada')   
ORDER BY TerritoryName;

TerritoryName            BusinessEntityID SalesYTD              NextRepSales  
-----------------------  ---------------- --------------------- ---------------------  
Canada                   282              2604540.7172          1453719.4653  
Canada                   278              1453719.4653          0.00  
Northwest                284              1576562.1966          1573012.9383  
Northwest                283              1573012.9383          1352577.1325  
Northwest                280              1352577.1325          0.00


-----------------------------------------------------------------------------------
-- C. Specifying arbitrary expressions
-- The following example demonstrates specifying a variety of arbitrary expressions in the LEAD function syntax.
-----------------------------------------------------------------------------------
CREATE TABLE T (a int, b int, c int);   
GO  
INSERT INTO T VALUES (1, 1, -3), (2, 2, 4), (3, 1, NULL), (4, 3, 1), (5, 2, NULL), (6, 1, 5);   
  
SELECT b, c,   
    LEAD(2*c, b*(SELECT MIN(b) FROM T), -c/2.0) OVER (ORDER BY a) AS i  
FROM T;

b           c           i  
----------- ----------- -----------  
1           -3          8  
2           4           2  
1           NULL        2  
3           1           0  
2           NULL        NULL  
1           5           -2
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PERCENTILE_CONT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Calculates a percentile based on a continuous distribution of the column value in SQL Server. The result is interpolated and might not be equal to any of the specific values in the column.</Description>
    <Syntax><![CDATA[<pre> PERCENTILE_CONT ( numeric_literal ) WITHIN GROUP ( ORDER BY order_by_expression [ ASC | DESC ] ) OVER ( [ <partition_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/percentile-cont-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------
-- A. Basic syntax example
-- The following example uses PERCENTILE_CONT and PERCENTILE_DISC to find the median employee salary in each department. These functions may not return the same value. PERCENTILE_CONT interpolates the appropriate value, which may or may not exist in the data set, while PERCENTILE_DISC always returns an actual value from the set.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
  
SELECT DISTINCT Name AS DepartmentName  
      ,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ph.Rate)   
                            OVER (PARTITION BY Name) AS MedianCont  
      ,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY ph.Rate)   
                            OVER (PARTITION BY Name) AS MedianDisc  
FROM HumanResources.Department AS d  
INNER JOIN HumanResources.EmployeeDepartmentHistory AS dh   
    ON dh.DepartmentID = d.DepartmentID  
INNER JOIN HumanResources.EmployeePayHistory AS ph  
    ON ph.BusinessEntityID = dh.BusinessEntityID  
WHERE dh.EndDate IS NULL;

DepartmentName        MedianCont    MedianDisc
--------------------   ----------   ----------
Document Control       16.8269      16.8269
Engineering            34.375       32.6923
Executive              54.32695     48.5577
Human Resources        17.427850    16.5865


-----------------------------------------------------------------------------------
-- B. Basic syntax example
-- The following example uses PERCENTILE_CONT and PERCENTILE_DISC to find the median employee salary in each department. These functions may not return the same value. PERCENTILE_CONT interpolates the appropriate value, which may or may not exist in the data set, while PERCENTILE_DISC always returns an actual value from the set.
-----------------------------------------------------------------------------------
-- Uses AdventureWorks  
  
SELECT DISTINCT DepartmentName  
,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY BaseRate)  
    OVER (PARTITION BY DepartmentName) AS MedianCont  
,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY BaseRate)  
    OVER (PARTITION BY DepartmentName) AS MedianDisc  
FROM dbo.DimEmployee;

DepartmentName        MedianCont    MedianDisc
--------------------   ----------   ----------
Document Control       16.826900    16.8269
Engineering            34.375000    32.6923
Human Resources        17.427850    16.5865
Shipping and Receiving 9.250000      9.0000
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PERCENTILE_DISC</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Computes a specific percentile for sorted values in an entire rowset or within a rowset's distinct partitions in SQL Server. For a given percentile value P, PERCENTILE_DISC sorts the expression values in the ORDER BY clause. It then returns the value with the smallest CUME_DIST value given (with respect to the same sort specification) that is greater than or equal to P. For example, PERCENTILE_DISC (0.5) will compute the 50th percentile (that is, the median) of an expression. PERCENTILE_DISC calculates the percentile based on a discrete distribution of the column values. The result is equal to a specific column value.</Description>
    <Syntax><![CDATA[<pre> PERCENTILE_DISC ( numeric_literal ) WITHIN GROUP ( ORDER BY order_by_expression [ ASC | DESC ] ) OVER ( [ <partition_by_clause> ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/percentile-disc-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------
-- The following example uses PERCENTILE_CONT and PERCENTILE_DISC to find each department's median employee salary. They may not return the same value:
-- * PERCENTILE_CONT returns the appropriate value, even if it doesn't exist in the data set.
-- * PERCENTILE_DISC returns an actual set value.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
  
SELECT DISTINCT Name AS DepartmentName  
      ,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ph.Rate)   
                            OVER (PARTITION BY Name) AS MedianCont  
      ,PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY ph.Rate)   
                            OVER (PARTITION BY Name) AS MedianDisc  
FROM HumanResources.Department AS d  
INNER JOIN HumanResources.EmployeeDepartmentHistory AS dh   
    ON dh.DepartmentID = d.DepartmentID  
INNER JOIN HumanResources.EmployeePayHistory AS ph  
    ON ph.BusinessEntityID = dh.BusinessEntityID  
WHERE dh.EndDate IS NULL;

DepartmentName        MedianCont    MedianDisc
--------------------   ----------   ----------
Document Control       16.8269      16.8269
Engineering            34.375       32.6923
Executive              54.32695     48.5577
Human Resources        17.427850    16.5865
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PERCENT_RANK</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Calculates the relative rank of a row within a group of rows in SQL Server 2019 (15.x). Use PERCENT_RANK to evaluate the relative standing of a value within a query result set or partition. PERCENT_RANK is similar to the CUME_DIST function.</Description>
    <Syntax><![CDATA[<pre> PERCENT_RANK( ) OVER ( [ partition_by_clause ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/percent-rank-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------
-- The following example uses the CUME_DIST function to compute the salary percentile for each employee within a given department. The value returned by the CUME_DIST function represents the percent of employees that have a salary less than or equal to the current employee in the same department. The PERCENT_RANK function computes the rank of the employee's salary within a department as a percentage. The PARTITION BY clause is specified to partition the rows in the result set by department. The ORDER BY clause in the OVER clause orders the rows in each partition. The ORDER BY clause in the SELECT statement sorts the rows in the whole result set.
-----------------------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
SELECT Department, LastName, Rate,   
       CUME_DIST () OVER (PARTITION BY Department ORDER BY Rate) AS CumeDist,   
       PERCENT_RANK() OVER (PARTITION BY Department ORDER BY Rate ) AS PctRank  
FROM HumanResources.vEmployeeDepartmentHistory AS edh  
    INNER JOIN HumanResources.EmployeePayHistory AS e    
    ON e.BusinessEntityID = edh.BusinessEntityID  
WHERE Department IN (N'Information Services',N'Document Control')   
ORDER BY Department, Rate DESC;

Department             LastName               Rate                  CumeDist               PctRank  
---------------------- ---------------------- --------------------- ---------------------- ----------------------  
Document Control       Arifin                 17.7885               1                      1  
Document Control       Norred                 16.8269               0.8                    0.5  
Document Control       Kharatishvili          16.8269               0.8                    0.5  
Document Control       Chai                   10.25                 0.4                    0  
Document Control       Berge                  10.25                 0.4                    0  
Information Services   Trenary                50.4808               1                      1  
Information Services   Conroy                 39.6635               0.9                    0.888888888888889  
Information Services   Ajenstat               38.4615               0.8                    0.666666666666667  
Information Services   Wilson                 38.4615               0.8                    0.666666666666667  
Information Services   Sharma                 32.4519               0.6                    0.444444444444444  
Information Services   Connelly               32.4519               0.6                    0.444444444444444  
Information Services   Berg                   27.4038               0.4                    0  
Information Services   Meyyappan              27.4038               0.4                    0  
Information Services   Bacon                  27.4038               0.4                    0  
Information Services   Bueno                  27.4038               0.4                    0  
(15 row(s) affected)
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Collation Functions (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>COLLATIONPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the requested property of a specified collation.</Description>
    <Syntax><![CDATA[<pre> COLLATIONPROPERTY( collation_name , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/collation-functions-collationproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT COLLATIONPROPERTY('Traditional_Spanish_CS_AS_KS_WS', 'CodePage');  
Results: 1252   

-- Azure Synapse Analytics (SQL DW) and Parallel Data Warehouse
SELECT COLLATIONPROPERTY('Traditional_Spanish_CS_AS_KS_WS', 'CodePage')
Results: 1252   
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TERTIARY_WEIGHTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>For each character in a non-Unicode string expression - defined with a SQL tertiary collation - this function returns a binary string of weights.</Description>
    <Syntax><![CDATA[<pre> TERTIARY_WEIGHTS( non_Unicode_character_string_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/collation-functions-tertiary-weights-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example creates a computed column in a table that applies the TERTIARY_WEIGHTS function to the values of a char column:
CREATE TABLE TertColTable  
(Col1 char(15) COLLATE SQL_Latin1_General_Pref_CP437_CI_AS,  
Col2 AS TERTIARY_WEIGHTS(Col1));  
GO
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Conversion Functions (Transact-SQL) ========================================= -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>CAST</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>These functions convert an expression of one data type to another.</Description>
    <Syntax><![CDATA[<pre> CAST ( expression AS data_type [ ( length ) ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> see URL </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CONVERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>These functions convert an expression of one data type to another.</Description>
    <Syntax><![CDATA[<pre> CONVERT ( data_type [ ( length ) ] , expression [ , style ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> see URL </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PARSE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the result of an expression, translated to the requested data type in SQL Server.</Description>
    <Syntax><![CDATA[<pre> PARSE ( string_value AS data_type [ USING culture ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/parse-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- A. PARSE into datetime2
SELECT PARSE('Monday, 13 December 2010' AS datetime2 USING 'en-US') AS Result;
Result: 2010-12-13 00:00:00.0000000

-- B. PARSE with currency symbol
SELECT PARSE('€345,98' AS money USING 'de-DE') AS Result;  
Result: 345.98

-- C. PARSE with implicit setting of language 
-- The English language is mapped to en-US specific culture  
SET LANGUAGE 'English';  
SELECT PARSE('12/16/2010' AS datetime2) AS Result;  
Result: 2010-12-16 00:00:00.0000000 
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRY_CAST</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a value cast to the specified data type if the cast succeeds; otherwise, returns null.</Description>
    <Syntax><![CDATA[<pre> TRY_CAST ( expression AS data_type [ ( length ) ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/try-cast-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
----------------------------------------------------------------------------
-- A. TRY_CAST returns null
-- The following example demonstrates that TRY_CAST returns null when the cast fails.
----------------------------------------------------------------------------
SELECT   
    CASE WHEN TRY_CAST('test' AS float) IS NULL   
    THEN 'Cast failed'  
    ELSE 'Cast succeeded'  
END AS Result;  
GO
Result: Cast failed  

----------------------------------------------------------------------------
-- The following example demonstrates that the expression must be in the expected format.
----------------------------------------------------------------------------
SET DATEFORMAT dmy;  
SELECT TRY_CAST('12/31/2010' AS datetime2) AS Result;  
GO
Result: NULL    

----------------------------------------------------------------------------
-- B. TRY_CAST fails with an error
-- The following example demonstrates that TRY_CAST returns an error when the cast is explicitly not permitted.
----------------------------------------------------------------------------
SELECT TRY_CAST(4 AS xml) AS Result;  
GO
--The result of this statement is an error, because an integer cannot be cast into an xml data type.
Explicit conversion from data type int to xml is not allowed.  

----------------------------------------------------------------------------
-- C. TRY_CAST succeeds
-- This example demonstrates that the expression must be in the expected format.
----------------------------------------------------------------------------
SET DATEFORMAT mdy;  
SELECT TRY_CAST('12/31/2010' AS datetime2) AS Result;  
GO
Result: 2010-12-31 00:00:00.0000000  
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRY_CONVERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a value cast to the specified data type if the cast succeeds; otherwise, returns null.</Description>
    <Syntax><![CDATA[<pre> TRY_CONVERT ( data_type [ ( length ) ], expression [, style ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/try-convert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-------------------------------------------------------------------------------
-- A. TRY_CONVERT returns null
-- The following example demonstrates that TRY_CONVERT returns null when the cast fails.
-------------------------------------------------------------------------------
SELECT   
    CASE WHEN TRY_CONVERT(float, 'test') IS NULL   
    THEN 'Cast failed'  
    ELSE 'Cast succeeded'  
END AS Result;  
GO
Results: Cast failed

-------------------------------------------------------------------------------
-- The following example demonstrates that the expression must be in the expected format.
-------------------------------------------------------------------------------
SET DATEFORMAT dmy;  
SELECT TRY_CONVERT(datetime2, '12/31/2010') AS Result;  
GO
Results: NULL  

-------------------------------------------------------------------------------
-- B. TRY_CONVERT fails with an error
-- The following example demonstrates that TRY_CONVERT returns an error when the cast is explicitly not permitted.
-------------------------------------------------------------------------------
SELECT TRY_CONVERT(xml, 4) AS Result;  
GO
-- The result of this statement is an error, because an integer cannot be cast into an xml data type.
Explicit conversion from data type int to xml is not allowed.  

-------------------------------------------------------------------------------
-- C. TRY_CONVERT succeeds
-- This example demonstrates that the expression must be in the expected format.
-------------------------------------------------------------------------------
SET DATEFORMAT mdy;  
SELECT TRY_CONVERT(datetime2, '12/31/2010') AS Result;  
GO
Reults: 2010-12-31 00:00:00.0000000  
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRY_PARSE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the result of an expression, translated to the requested data type, or null if the cast fails in SQL Server. Use TRY_PARSE only for converting from string to date/time and number types.</Description>
    <Syntax><![CDATA[<pre> TRY_PARSE ( string_value AS data_type [ USING culture ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/try-parse-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-------------------------------------------------------------------------------
-- A. Simple example of TRY_PARSE
-------------------------------------------------------------------------------
SELECT TRY_PARSE('Jabberwokkie' AS datetime2 USING 'en-US') AS Result;  
Results: NULL  

-------------------------------------------------------------------------------
-- B. Detecting nulls with TRY_PARSE
-------------------------------------------------------------------------------
SELECT  
    CASE WHEN TRY_PARSE('Aragorn' AS decimal USING 'sr-Latn-CS') IS NULL  
        THEN 'True'  
        ELSE 'False'  
END  
AS Result;

Results: True  

-------------------------------------------------------------------------------
-- C. Using IIF with TRY_PARSE and implicit culture setting
-------------------------------------------------------------------------------
SET LANGUAGE English;  
SELECT IIF(TRY_PARSE('01/01/2011' AS datetime2) IS NULL, 'True', 'False') AS Result;

Results: False  
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Cryptographic functions (Transact-SQL) ====================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>ASYMKEY_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the ID of an asymmetric key.</Description>
    <Syntax><![CDATA[<pre> ASYMKEY_ID ( 'Asym_Key_Name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/asymkey-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example returns the ID of asymmetric key ABerglundKey11.
SELECT ASYMKEY_ID('ABerglundKey11');  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ASYMKEYPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the properties of an asymmetric key.</Description>
    <Syntax><![CDATA[<pre> ASYMKEYPROPERTY (Key_ID , 'algorithm_desc' | 'string_sid' | 'sid') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/asymkeyproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the properties of the asymmetric key of Key_ID 256.
SELECT   
ASYMKEYPROPERTY(256, 'algorithm_desc') AS Algorithm,  
ASYMKEYPROPERTY(256, 'string_sid') AS String_SID,  
ASYMKEYPROPERTY(256, 'sid') AS SID ;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CERTPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the value of a specified certificate property.</Description>
    <Syntax><![CDATA[<pre> CertProperty ( Cert_ID , '<PropertyName>' ) <PropertyName> ::= Expiry_Date | Start_Date | Issuer_Name | Cert_Serial_Number | Subject | SID | String_SID </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/certproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the certificate subject.

-- First create a certificate.  
CREATE CERTIFICATE Marketing19 WITH   
    START_DATE = '04/04/2004' ,  
    EXPIRY_DATE = '07/07/2040' ,  
    SUBJECT = 'Marketing Print Division';  
GO  
  
-- Now use CertProperty to examine certificate  
-- Marketing19's properties.  
DECLARE @CertSubject sql_variant;  
set @CertSubject = CertProperty( Cert_ID('Marketing19'), 'Subject');  
PRINT CONVERT(nvarchar, @CertSubject);  
GO 
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CERT_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the ID value of a certificate.</Description>
    <Syntax><![CDATA[<pre> Cert_ID ( 'cert_name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cert-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example returns the ID of a certificate named ABerglundCert3.
SELECT Cert_ID('ABerglundCert3');  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CRYPT_GEN_RANDOM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a cryptographic, randomly-generated number, generated by the Crypto API (CAPI). CRYPT_GEN_RANDOM returns a hexadecimal number with a length of a specified number of bytes.</Description>
    <Syntax><![CDATA[<pre> CRYPT_GEN_RANDOM ( length [ , seed ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/crypt-gen-random-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example generates a random number of length 50 bytes:
SELECT CRYPT_GEN_RANDOM(50) ;

-- This example generates a random number of length 4 bytes, using a 4-byte seed:
SELECT CRYPT_GEN_RANDOM(4, 0x25F18060) ;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYASYMKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function uses an asymmetric key to decrypt encrypted data.</Description>
    <Syntax><![CDATA[<pre> DecryptByAsymKey (Asym_Key_ID , { 'ciphertext' | @ciphertext } [ , 'Asym_Key_Password' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbyasymkey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example decrypts ciphertext originally encrypted with asymmetric key JanainaAsymKey02. AdventureWorks2012.ProtectedData04 stored this asymmetric key. The example decrypted the returned data with asymmetric key JanainaAsymKey02. The example used password pGFD4bb925DGvbd2439587y to decrypt this asymmetric key. The example converted the returned plaintext to type nvarchar.
SELECT CONVERT(nvarchar(max),  
    DecryptByAsymKey( AsymKey_Id('JanainaAsymKey02'),   
    ProtectedData, N'pGFD4bb925DGvbd2439587y' ))   
AS DecryptedData   
FROM [AdventureWorks2012].[Sales].[ProtectedData04]   
WHERE Description = N'encrypted by asym key''JanainaAsymKey02''';  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYCERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function uses the private key of a certificate to decrypt encrypted data.</Description>
    <Syntax><![CDATA[<pre> DecryptByCert ( certificate_ID , { 'ciphertext' | @ciphertext } [ , { 'cert_password' | @cert_password } ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbycert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example selects rows from [AdventureWorks2012].[ProtectedData04] marked as data originally encrypted by certificate JanainaCert02. The example first decrypts the private key of certificate JanainaCert02 with the password of certificate pGFD4bb925DGvbd2439587y. Then, the example decrypts the ciphertext with this private key. The example converts the decrypted data from varbinary to nvarchar.
SELECT convert(nvarchar(max), DecryptByCert(Cert_Id('JanainaCert02'),  
    ProtectedData, N'pGFD4bb925DGvbd2439587y'))  
FROM [AdventureWorks2012].[ProtectedData04]   
WHERE Description   
    = N'data encrypted by certificate '' JanainaCert02''';  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function uses a symmetric key to decrypt data.</Description>
    <Syntax><![CDATA[<pre> DecryptByKey ( { 'ciphertext' | @ciphertext } [ , add_authenticator, { authenticator | @authenticator } ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbykey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
--------------------------------------------------------------------------------------------
-- This example decrypts ciphertext with a symmetric key.
--------------------------------------------------------------------------------------------
-- First, open the symmetric key with which to decrypt the data.  
OPEN SYMMETRIC KEY SSN_Key_01  
   DECRYPTION BY CERTIFICATE HumanResources037;  
GO  
  
-- Now list the original ID, the encrypted ID, and the   
-- decrypted ciphertext. If the decryption worked, the original  
-- and the decrypted ID will match.  
SELECT NationalIDNumber, EncryptedNationalID   
    AS 'Encrypted ID Number',  
    CONVERT(nvarchar, DecryptByKey(EncryptedNationalID))   
    AS 'Decrypted ID Number'  
    FROM HumanResources.Employee;  
GO

--------------------------------------------------------------------------------------------
-- This example decrypts data originally encrypted together with an authenticator.
--------------------------------------------------------------------------------------------
-- First, open the symmetric key with which to decrypt the data  
OPEN SYMMETRIC KEY CreditCards_Key11  
   DECRYPTION BY CERTIFICATE Sales09;  
GO  
  
-- Now list the original card number, the encrypted card number,  
-- and the decrypted ciphertext. If the decryption worked,   
-- the original number will match the decrypted number.  
SELECT CardNumber, CardNumber_Encrypted   
    AS 'Encrypted card number', CONVERT(nvarchar,  
    DecryptByKey(CardNumber_Encrypted, 1 ,   
    HashBytes('SHA1', CONVERT(varbinary, CreditCardID))))   
    AS 'Decrypted card number' FROM Sales.CreditCard;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYKEYAUTOASYMKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function decrypts encrypted data. To do this, it first decrypts a symmetric key with a separate asymmetric key, and then decrypts the encrypted data with the symmetric key extracted in the first "step".</Description>
    <Syntax><![CDATA[<pre> DecryptByKeyAutoAsymKey ( akey_ID , akey_password , { 'ciphertext' | @ciphertext } [ , { add_authenticator | @add_authenticator } [ , { authenticator | @authenticator } ] ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbykeyautoasymkey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------------------------
-- This example shows how DECRYPTBYKEYAUTOASYMKEY can simplify decryption code. This code should run on an AdventureWorks2012 database that does not already have a database master key.
-----------------------------------------------------------------------------------------

--Create the keys and certificate.  
USE AdventureWorks2012;  
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'mzkvdMlk979438teag$$ds987yghn)(*&4fdg^';  
OPEN MASTER KEY DECRYPTION BY PASSWORD = 'mzkvdMlk979438teag$$ds987yghn)(*&4fdg^';  
CREATE ASYMMETRIC KEY SSN_AKey   
    WITH ALGORITHM = RSA_2048 ;   
GO  
CREATE SYMMETRIC KEY SSN_Key_02 WITH ALGORITHM = DES  
    ENCRYPTION BY ASYMMETRIC KEY SSN_AKey;  
GO  
--  
--Add a column of encrypted data.  
ALTER TABLE HumanResources.Employee  
    ADD EncryptedNationalIDNumber2 varbinary(128);   
OPEN SYMMETRIC KEY SSN_Key_02  
   DECRYPTION BY ASYMMETRIC KEY SSN_AKey;  
UPDATE HumanResources.Employee  
SET EncryptedNationalIDNumber2  
    = EncryptByKey(Key_GUID('SSN_Key_02'), NationalIDNumber);  
GO  
--Close the key used to encrypt the data.  
CLOSE SYMMETRIC KEY SSN_Key_02;  
--  
--There are two ways to decrypt the stored data.  
--  
--OPTION ONE, using DecryptByKey()  
--1. Open the symmetric key.  
--2. Decrypt the data.  
--3. Close the symmetric key.  
OPEN SYMMETRIC KEY SSN_Key_02  
   DECRYPTION BY ASYMMETRIC KEY SSN_AKey;  
SELECT NationalIDNumber, EncryptedNationalIDNumber2    
    AS 'Encrypted ID Number',  
    CONVERT(nvarchar, DecryptByKey(EncryptedNationalIDNumber2))   
    AS 'Decrypted ID Number'  
    FROM HumanResources.Employee;  
CLOSE SYMMETRIC KEY SSN_Key_02;  
--  
--OPTION TWO, using DecryptByKeyAutoAsymKey()  
SELECT NationalIDNumber, EncryptedNationalIDNumber2   
    AS 'Encrypted ID Number',  
    CONVERT(nvarchar, DecryptByKeyAutoAsymKey ( AsymKey_ID('SSN_AKey') , NULL ,EncryptedNationalIDNumber2))   
    AS 'Decrypted ID Number'  
    FROM HumanResources.Employee;  
GO
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYKEYAUTOCERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function decrypts data with a symmetric key. That symmetric key automatically decrypts with a certificate.</Description>
    <Syntax><![CDATA[<pre> DecryptByKeyAutoCert ( cert_ID , cert_password , { 'ciphertext' | @ciphertext } [ , { add_authenticator | @add_authenticator } [ , { authenticator | @authenticator } ] ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbykeyautocert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-------------------------------------------------------------------
-- This example shows how DECRYPTBYKEYAUTOCERT can simplify decryption code. This code should run on an AdventureWorks2012 database that does not already have a database master key.
-------------------------------------------------------------------

--Create the keys and certificate.  
USE AdventureWorks2012;  
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'mzkvdlk979438teag$$ds987yghn)(*&4fdg^';  
OPEN MASTER KEY DECRYPTION BY PASSWORD = 'mzkvdlk979438teag$$ds987yghn)(*&4fdg^';  
CREATE CERTIFICATE HumanResources037   
   WITH SUBJECT = 'Sammamish HR',   
   EXPIRY_DATE = '10/31/2009';  
CREATE SYMMETRIC KEY SSN_Key_01 WITH ALGORITHM = DES  
    ENCRYPTION BY CERTIFICATE HumanResources037;  
GO  
----Add a column of encrypted data.  
ALTER TABLE HumanResources.Employee  
    ADD EncryptedNationalIDNumber varbinary(128);   
OPEN SYMMETRIC KEY SSN_Key_01  
   DECRYPTION BY CERTIFICATE HumanResources037 ;  
UPDATE HumanResources.Employee  
SET EncryptedNationalIDNumber  
    = EncryptByKey(Key_GUID('SSN_Key_01'), NationalIDNumber);  
GO  
--  
--Close the key used to encrypt the data.  
CLOSE SYMMETRIC KEY SSN_Key_01;  
--  
--There are two ways to decrypt the stored data.  
--  
--OPTION ONE, using DecryptByKey()  
--1. Open the symmetric key  
--2. Decrypt the data  
--3. Close the symmetric key  
OPEN SYMMETRIC KEY SSN_Key_01  
   DECRYPTION BY CERTIFICATE HumanResources037;  
SELECT NationalIDNumber, EncryptedNationalIDNumber    
    AS 'Encrypted ID Number',  
    CONVERT(nvarchar, DecryptByKey(EncryptedNationalIDNumber))   
    AS 'Decrypted ID Number'  
    FROM HumanResources.Employee;  
CLOSE SYMMETRIC KEY SSN_Key_01;  
--  
--OPTION TWO, using DecryptByKeyAutoCert()  
SELECT NationalIDNumber, EncryptedNationalIDNumber   
    AS 'Encrypted ID Number',  
    CONVERT(nvarchar, DecryptByKeyAutoCert ( cert_ID('HumanResources037') , NULL ,EncryptedNationalIDNumber))   
    AS 'Decrypted ID Number'  
    FROM HumanResources.Employee;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECRYPTBYPASSPHRASE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function decrypts data originally encrypted with a passphrase.</Description>
    <Syntax><![CDATA[<pre> DecryptByPassPhrase ( { 'passphrase' | @passphrase } , { 'ciphertext' | @ciphertext } [ , { add_authenticator | @add_authenticator } , { authenticator | @authenticator } ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decryptbypassphrase-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example decrypts the record updated in EncryptByPassPhrase.
USE AdventureWorks2012;  
-- Get the pass phrase from the user.  
DECLARE @PassphraseEnteredByUser nvarchar(128);  
SET @PassphraseEnteredByUser   
= 'A little learning is a dangerous thing!';  
  
-- Decrypt the encrypted record.  
SELECT CardNumber, CardNumber_EncryptedbyPassphrase   
    AS 'Encrypted card number', CONVERT(nvarchar,  
    DecryptByPassphrase(@PassphraseEnteredByUser, CardNumber_EncryptedbyPassphrase, 1   
    , CONVERT(varbinary, CreditCardID)))  
    AS 'Decrypted card number' FROM Sales.CreditCard   
    WHERE CreditCardID = '3681';  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ENCRYPTBYASYMKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function encrypts data with an asymmetric key.</Description>
    <Syntax><![CDATA[<pre> EncryptByAsymKey ( Asym_Key_ID , { 'plaintext' | @plaintext } ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/encryptbyasymkey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example encrypts the text stored in @cleartext with the asymmetric key JanainaAsymKey02. The statement inserts the encrypted data into the ProtectedData04 table.
INSERT INTO AdventureWorks2012.Sales.ProtectedData04   
    VALUES( N'Data encrypted by asymmetric key ''JanainaAsymKey02''',  
    EncryptByAsymKey(AsymKey_ID('JanainaAsymKey02'), @cleartext) );  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ENCRYPTBYCERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Encrypts data with the public key of a certificate.</Description>
    <Syntax><![CDATA[<pre> EncryptByCert ( certificate_ID , { 'cleartext' | @cleartext } ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/encryptbycert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This example encrypts the plaintext stored in @cleartext with the certificate called JanainaCert02. The encrypted data is inserted into table ProtectedData04.
INSERT INTO [AdventureWorks2012].[ProtectedData04]   
    VALUES ( N'Data encrypted by certificate ''Shipping04''',  
    EncryptByCert(Cert_ID('JanainaCert02'), @cleartext) );  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ENCRYPTBYKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Encrypts data by using a symmetric key.</Description>
    <Syntax><![CDATA[<pre> EncryptByKey ( key_GUID , { 'cleartext' | @cleartext } [, { add_authenticator | @add_authenticator } , { authenticator | @authenticator } ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/encryptbykey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
---------------------------------------------------------------------
-- The following example adds a column to the Employee table, and then encrypts the value of the Social Security number that is stored in column NationalIDNumber.
---------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
  
-- Create a column in which to store the encrypted data.  
ALTER TABLE HumanResources.Employee  
    ADD EncryptedNationalIDNumber varbinary(128);   
GO  
  
-- Open the symmetric key with which to encrypt the data.  
OPEN SYMMETRIC KEY SSN_Key_01  
   DECRYPTION BY CERTIFICATE HumanResources037;  
  
-- Encrypt the value in column NationalIDNumber with symmetric key  
-- SSN_Key_01. Save the result in column EncryptedNationalIDNumber.  
UPDATE HumanResources.Employee  
SET EncryptedNationalIDNumber  
    = EncryptByKey(Key_GUID('SSN_Key_01'), NationalIDNumber);  
GO

---------------------------------------------------------------------
-- Encrypting a record together with an authentication value
---------------------------------------------------------------------
USE AdventureWorks2012;  
  
-- Create a column in which to store the encrypted data.  
ALTER TABLE Sales.CreditCard   
    ADD CardNumber_Encrypted varbinary(128);   
GO  
  
-- Open the symmetric key with which to encrypt the data.  
OPEN SYMMETRIC KEY CreditCards_Key11  
    DECRYPTION BY CERTIFICATE Sales09;  
  
-- Encrypt the value in column CardNumber with symmetric   
-- key CreditCards_Key11.  
-- Save the result in column CardNumber_Encrypted.    
UPDATE Sales.CreditCard  
SET CardNumber_Encrypted = EncryptByKey(Key_GUID('CreditCards_Key11'),   
    CardNumber, 1, CONVERT( varbinary, CreditCardID) );  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ENCRYPTBYPASSPHRASE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Encrypt data with a passphrase using the TRIPLE DES algorithm with a 128 key bit length.</Description>
    <Syntax><![CDATA[<pre> EncryptByPassPhrase ( { 'passphrase' | @passphrase } , { 'cleartext' | @cleartext } [ , { add_authenticator | @add_authenticator } , { authenticator | @authenticator } ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/encryptbypassphrase-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-----------------------------------------------------------------------
-- The following example updates a record in the SalesCreditCard table and encrypts the value of the credit card number stored in column CardNumber_EncryptedbyPassphrase, using the primary key as an authenticator.
-----------------------------------------------------------------------
USE AdventureWorks2012;  
GO  
-- Create a column in which to store the encrypted data.  
ALTER TABLE Sales.CreditCard   
    ADD CardNumber_EncryptedbyPassphrase varbinary(256);   
GO  
-- First get the passphrase from the user.  
DECLARE @PassphraseEnteredByUser nvarchar(128);  
SET @PassphraseEnteredByUser   
    = 'A little learning is a dangerous thing!';  
  
-- Update the record for the user's credit card.  
-- In this case, the record is number 3681.  
UPDATE Sales.CreditCard  
SET CardNumber_EncryptedbyPassphrase = EncryptByPassPhrase(@PassphraseEnteredByUser  
    , CardNumber, 1, CONVERT( varbinary, CreditCardID))  
WHERE CreditCardID = '3681';  
GO
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>HASHBYTES</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the MD2, MD4, MD5, SHA, SHA1, or SHA2 hash of its input in SQL Server.</Description>
    <Syntax><![CDATA[<pre> HASHBYTES ( '<algorithm>', { @input | 'input' } ) <algorithm>::= MD2 | MD4 | MD5 | SHA | SHA1 | SHA2_256 | SHA2_512 </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/hashbytes-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
----------------------------------------------------------------------
-- The following example returns the SHA2_256 hash of the nvarchar data stored in variable @HashThis.
----------------------------------------------------------------------
DECLARE @HashThis nvarchar(32);  
SET @HashThis = CONVERT(nvarchar(32),'dslfdkjLK85kldhnv$n000#knf');  
SELECT HASHBYTES('SHA2_256', @HashThis);

----------------------------------------------------------------------
-- The following example returns the SHA2_256 hash of the values in column c1 in the table Test1.
----------------------------------------------------------------------
CREATE TABLE dbo.Test1 (c1 nvarchar(32));  
INSERT dbo.Test1 VALUES ('This is a test.');  
INSERT dbo.Test1 VALUES ('This is test 2.');  
SELECT HASHBYTES('SHA2_256', c1) FROM dbo.Test1;

-------------------------------------------  
0x741238C01D9DB821CF171BF61D72260B998F7C7881D90091099945E0B9E0C2E3 
0x91DDCC41B761ACA928C62F7B0DA61DC763255E8247E0BD8DCE6B22205197154D  
(2 row(s) affected)

 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IS_OBJECTSIGNED</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Indicates whether an object is signed by a specified certificate or asymmetric key.</Description>
    <Syntax><![CDATA[<pre> IS_OBJECTSIGNED ( 'OBJECT', @object_id, @class, @thumbprint ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/is-objectsigned-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
--------------------------------------------------------
-- The following example tests if the spt_fallback_db table in the master database is signed by the schema signing certificate.
--------------------------------------------------------
USE master;  
-- Declare a variable to hold a thumbprint and an object name  
DECLARE @thumbprint varbinary(20), @objectname sysname;  
  
-- Populate the thumbprint variable with the thumbprint of   
-- the master database schema signing certificate  
SELECT @thumbprint = thumbprint   
FROM sys.certificates   
WHERE name LIKE '%SchemaSigningCertificate%';  
  
-- Populate the object name variable with a table name in master  
SELECT @objectname = 'spt_fallback_db';  
  
-- Query to see if the table is signed by the thumbprint  
SELECT @objectname AS [object name],  
IS_OBJECTSIGNED(  
'OBJECT', OBJECT_ID(@objectname), 'certificate', @thumbprint  
) AS [Is the object signed?] ;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>KEY_GUID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the GUID of a symmetric key in the database.</Description>
    <Syntax><![CDATA[<pre> Key_GUID( 'Key_Name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/key-guid-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the GUID of a symmetric key called ABerglundKey1.
SELECT Key_GUID('ABerglundKey1');
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>KEY_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the ID of a symmetric key in the current database.</Description>
    <Syntax><![CDATA[<pre> Key_ID ( 'Key_Name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/key-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the ID of a key called ABerglundKey1.
SELECT KEY_ID('ABerglundKey1');

-- The following example returns the ID of a temporary symmetric key. Note that # is prepended to the key name.
SELECT KEY_ID('#ABerglundKey2');
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>KEY_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the name of the symmetric key from either a symmetric key GUID or cipher text.</Description>
    <Syntax><![CDATA[<pre> KEY_NAME ( ciphertext | key_guid ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/key-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre>
---------------------------------------------------------------------------
-- A. Displaying the name of a symmetric key using the key_guid
-- The master database contains a symmetric key named ##MS_ServiceMasterKey##. The following example gets the GUID of that key from the sys.symmetric_keys dynamic management view, assigns it to a variable, and then passes that variable to the KEY_NAME function to demonstrate how to return the name that corresponds to the GUID.
---------------------------------------------------------------------------
USE master;  
GO  
DECLARE @guid uniqueidentifier ;  
SELECT @guid = key_guid FROM sys.symmetric_keys  
WHERE name = '##MS_ServiceMasterKey##' ;  
-- Demonstration of passing a GUID to KEY_NAME to receive a name  
SELECT KEY_NAME(@guid) AS [Name of Key];

---------------------------------------------------------------------------
-- B. Displaying the name of a symmetric key using the cipher text
-- The following example demonstrates the entire process of creating a symmetric key and populating data into a table. The example then shows how KEY_NAME returns the name of the key when passed the encrypted text.
---------------------------------------------------------------------------
-- Create a symmetric key  
CREATE SYMMETRIC KEY TestSymKey   
   WITH ALGORITHM = AES_128,  
   KEY_SOURCE = 'The square of the hypotenuse is equal to the sum of the squares of the sides',  
   IDENTITY_VALUE = 'Pythagoras'  
   ENCRYPTION BY PASSWORD = 'pGFD4bb925DGvbd2439587y' ;  
GO  
-- Create a table for the demonstration  
CREATE TABLE DemoKey  
(IDCol int IDENTITY PRIMARY KEY,  
SecretCol varbinary(256) NOT NULL)  
GO  
-- Open the symmetric key if not already open  
OPEN SYMMETRIC KEY TestSymKey   
    DECRYPTION BY PASSWORD = 'pGFD4bb925DGvbd2439587y';  
GO  
-- Insert a row into the DemoKey table  
DECLARE @key_GUID uniqueidentifier;  
SELECT @key_GUID = key_guid FROM sys.symmetric_keys  
WHERE name LIKE 'TestSymKey' ;  
INSERT INTO DemoKey(SecretCol)  
VALUES ( ENCRYPTBYKEY (@key_GUID, 'EncryptedText'))  
GO  
-- Verify the DemoKey data  
SELECT * FROM DemoKey;  
GO  
-- Decrypt the data  
DECLARE @ciphertext varbinary(256);  
SELECT @ciphertext = SecretCol  
FROM DemoKey WHERE IDCol = 1 ;  
SELECT CAST (  
DECRYPTBYKEY( @ciphertext)  
AS varchar(100) ) AS SecretText ;  
-- Use KEY_NAME to view the name of the key  
SELECT KEY_NAME(@ciphertext) AS [Name of Key] ;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SIGNBYASYMKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Signs plaintext with an asymmetric key</Description>
    <Syntax><![CDATA[<pre> SignByAsymKey( Asym_Key_ID , @plaintext [ , 'password' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/signbyasymkey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-------------------------------------------------------------------
-- The following example creates a table, SignedData04, in which to store plaintext and its signature. It next inserts a record in the table, signed with asymmetric key PrimeKey, which is first decrypted with password 'pGFD4bb925DGvbd2439587y'.
-------------------------------------------------------------------
-- Create a table in which to store the data  
CREATE TABLE [SignedData04](Description nvarchar(max), Data nvarchar(max), DataSignature varbinary(8000));  
GO  
-- Store data together with its signature  
DECLARE @clear_text_data nvarchar(max);  
set @clear_text_data = N'Important numbers 2, 3, 5, 7, 11, 13, 17,   
      19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,  
      83, 89, 97';  
INSERT INTO [SignedData04]   
    VALUES( N'data encrypted by asymmetric key ''PrimeKey''',  
    @clear_text_data, SignByAsymKey( AsymKey_Id( 'PrimeKey' ),  
    @clear_text_data, N'pGFD4bb925DGvbd2439587y' ));  
GO
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SIGNBYCERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Signs text with a certificate and returns the signature.</Description>
    <Syntax><![CDATA[<pre> SignByCert ( certificate_ID , @cleartext [ , 'password' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/signbycert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example signs the text in @SensitiveData with certificate ABerglundCert07, having first decrypted the certificate with password "pGFD4bb925DGvbd2439587y". It then inserts the cleartext and the signature in table SignedData04.
DECLARE @SensitiveData nvarchar(max);  
SET @SensitiveData = N'Saddle Price Points are   
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29';  
INSERT INTO [SignedData04]  
    VALUES( N'data signed by certificate ''ABerglundCert07''',  
    @SensitiveData, SignByCert( Cert_Id( 'ABerglundCert07' ),   
    @SensitiveData, N'pGFD4bb925DGvbd2439587y' ));  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SYMKEYPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the algorithm of a symmetric key created from an EKM module.</Description>
    <Syntax><![CDATA[<pre> SYMKEYPROPERTY ( Key_ID , 'algorithm_desc' | 'string_sid' | 'sid' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/symkeyproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the algorithm of the symmetric key with Key_ID 256.
SELECT SYMKEYPROPERTY(256, 'algorithm_desc') AS Algorithm ;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>VERIFYSIGNEDBYCERT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Tests whether digitally signed data has been changed since it was signed.</Description>
    <Syntax><![CDATA[<pre> VerifySignedByCert( Cert_ID , signed_data , signature ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/verifysignedbycert-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-------------------------------------------------------------------------------
-- A. Verifying that signed data has not been tampered with
-- The following example tests whether the information in Signed_Data has been changed since it was signed with the certificate called Shipping04. The signature is stored in DataSignature. The certificate, Shipping04, is passed to Cert_ID, which returns the ID of the certificate in the database. If VerifySignedByCert returns 1, the signature is correct. If VerifySignedByCert returns 0, the data in Signed_Data is not the data that was used to generate DataSignature. In this case, either Signed_Data has been changed since it was signed or Signed_Data was signed with a different certificate.
-------------------------------------------------------------------------------
SELECT Data, VerifySignedByCert( Cert_Id( 'Shipping04' ),  
    Signed_Data, DataSignature ) AS IsSignatureValid  
FROM [AdventureWorks2012].[SignedData04]   
WHERE Description = N'data signed by certificate ''Shipping04''';  
GO

-------------------------------------------------------------------------------
-- B. Returning only records that have a valid signature
-- This query returns only records that have not been changed since they were signed using certificate Shipping04.
-------------------------------------------------------------------------------
SELECT Data FROM [AdventureWorks2012].[SignedData04]   
WHERE VerifySignedByCert( Cert_Id( 'Shipping04' ), Data,   
    DataSignature ) = 1   
AND Description = N'data signed by certificate ''Shipping04''';  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>VERIFYSIGNEDBYASYMKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Tests whether digitally signed data has been changed since it was signed.</Description>
    <Syntax><![CDATA[<pre> VerifySignedByAsymKey( Asym_Key_ID , clear_text , signature ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/verifysignedbyasymkey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
------------------------------------------------------------------------------
-- A. Testing for data with a valid signature
-- The following example returns 1 if the selected data has not been changed since it was signed with asymmetric key WillisKey74. The example returns 0 if the data has been tampered with.
------------------------------------------------------------------------------
SELECT Data,  
     VerifySignedByAsymKey( AsymKey_Id( 'WillisKey74' ), SignedData,  
     DataSignature ) as IsSignatureValid  
FROM [AdventureWorks2012].[SignedData04]   
WHERE Description = N'data encrypted by asymmetric key ''WillisKey74''';  
GO  
RETURN;  

------------------------------------------------------------------------------
-- B. Returning a result set that contains data with a valid signature
-- The following example returns rows in SignedData04 that contain data that has not been changed since it was signed with asymmetric key WillisKey74. The example calls the function AsymKey_ID to obtain the ID of the asymmetric key from the database.
------------------------------------------------------------------------------
SELECT Data   
FROM [AdventureWorks2012].[SignedData04]   
WHERE VerifySignedByAsymKey( AsymKey_Id( 'WillisKey74' ), Data,  
     DataSignature ) = 1  
AND Description = N'data encrypted by asymmetric key ''WillisKey74''';  
GO
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Data Type Functions (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>DATALENGTH</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the number of bytes used to represent any expression.</Description>
    <Syntax><![CDATA[<pre> DATALENGTH ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datalength-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
USE AdventureWorks2016  
GO
SELECT length = DATALENGTH(EnglishProductName), EnglishProductName  
FROM dbo.DimProduct  
ORDER BY EnglishProductName;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IDENT_CURRENT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the last identity value generated for a specified table or view. The last identity value generated can be for any session and any scope.</Description>
    <Syntax><![CDATA[<pre> IDENT_CURRENT( 'table_or_view' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ident-current-transact-sql</SourceURL>
    <Example><![CDATA[<pre>
-- The following example returns the last identity value generated for the Person.Address table in the AdventureWorks2012 database.
SELECT IDENT_CURRENT ('Person.Address') AS Current_Identity;

-- The following example shows the different identity values that are returned by IDENT_CURRENT, @@IDENTITY, and SCOPE_IDENTITY
USE AdventureWorks2012;  
GO  
IF OBJECT_ID(N't6', N'U') IS NOT NULL   
    DROP TABLE t6;  
GO  
IF OBJECT_ID(N't7', N'U') IS NOT NULL   
    DROP TABLE t7;  
GO  
CREATE TABLE t6(id int IDENTITY);  
CREATE TABLE t7(id int IDENTITY(100,1));  
GO  
CREATE TRIGGER t6ins ON t6 FOR INSERT   
AS  
BEGIN  
   INSERT t7 DEFAULT VALUES  
END;  
GO  
--End of trigger definition  
  
SELECT id FROM t6;  
--IDs empty.  
  
SELECT id FROM t7;  
--ID is empty.  
  
--Do the following in Session 1  
INSERT t6 DEFAULT VALUES;  
SELECT @@IDENTITY;  
/*Returns the value 100. This was inserted by the trigger.*/  
  
SELECT SCOPE_IDENTITY();  
/* Returns the value 1. This was inserted by the   
INSERT statement two statements before this query.*/  
  
SELECT IDENT_CURRENT('t7');  
/* Returns value inserted into t7, that is in the trigger.*/  
  
SELECT IDENT_CURRENT('t6');  
/* Returns value inserted into t6. This was the INSERT statement four statements before this query.*/  
  
-- Do the following in Session 2.  
SELECT @@IDENTITY;  
/* Returns NULL because there has been no INSERT action   
up to this point in this session.*/  
  
SELECT SCOPE_IDENTITY();  
/* Returns NULL because there has been no INSERT action   
up to this point in this scope in this session.*/  
  
SELECT IDENT_CURRENT('t7');  
/* Returns the last value inserted into t7.*/
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IDENT_INCR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the increment value specified when creating a table or view's identity column.</Description>
    <Syntax><![CDATA[<pre> IDENT_INCR ( 'table_or_view' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ident-incr-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the increment value for the Person.Address table in the AdventureWorks2012 database.
USE AdventureWorks2012;  
GO  
SELECT IDENT_INCR('Person.Address') AS Identity_Increment;  
GO

-- The following example returns the tables in the AdventureWorks2012 database that includes an identity column with an increment value.
USE AdventureWorks2012;  
GO  
SELECT TABLE_SCHEMA, TABLE_NAME,   
   IDENT_INCR(TABLE_SCHEMA + '.' + TABLE_NAME) AS IDENT_INCR  
FROM INFORMATION_SCHEMA.TABLES  
WHERE IDENT_INCR(TABLE_SCHEMA + '.' + TABLE_NAME) IS NOT NULL;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IDENT_SEED</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the original seed value specified when creating an identity column in a table or a view. Changing the current value of an identity column by using DBCC CHECKIDENT doesn't change the value returned by this function.</Description>
    <Syntax><![CDATA[<pre> IDENT_SEED ( 'table_or_view' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ident-seed-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the seed value for the Person.Address table in the AdventureWorks2012 database.
USE AdventureWorks2012;  
GO  
SELECT IDENT_SEED('Person.Address') AS Identity_Seed;  
GO

-- The following example returns the tables in the AdventureWorks2012 database with an identity column with a seed value.
TABLE_SCHEMA       TABLE_NAME                   IDENT_SEED  
------------       ---------------------------  -----------  
Person             Address                                1  
Production         ProductReview                          1  
Production         TransactionHistory                100000  
Person             AddressType                            1  
Production         ProductSubcategory                     1  
Person             vAdditionalContactInfo                 1  
dbo                AWBuildVersion                         1
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IDENTITY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Is used only in a SELECT statement with an INTO table clause to insert an identity column into a new table. Although similar, the IDENTITY function is not the IDENTITY property that is used with CREATE TABLE and ALTER TABLE.</Description>
    <Syntax><![CDATA[<pre> IDENTITY (data_type [ , seed , increment ] ) AS column_name </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/identity-function-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
--The following example inserts all rows from the Contact table from the AdventureWorks2012database into a new table called NewContact. The IDENTITY function is used to start identification numbers at 100 instead of 1 in the NewContact table.
USE AdventureWorks2012;  
GO  
IF OBJECT_ID (N'Person.NewContact', N'U') IS NOT NULL  
    DROP TABLE Person.NewContact;  
GO  
ALTER DATABASE AdventureWorks2012 SET RECOVERY BULK_LOGGED;  
GO  
SELECT  IDENTITY(smallint, 100, 1) AS ContactNum,  
        FirstName AS First,  
        LastName AS Last  
INTO Person.NewContact  
FROM Person.Person;  
GO  
ALTER DATABASE AdventureWorks2012 SET RECOVERY FULL;  
GO  
SELECT ContactNum, First, Last FROM Person.NewContact;  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SQL_VARIANT_PROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the base data type and other information about a sql_variant value.</Description>
    <Syntax><![CDATA[<pre> SQL_VARIANT_PROPERTY ( expression , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sql-variant-property-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example retrieves SQL_VARIANT_PROPERTY information about the colA value 46279.1 where colB =1689, given that tableA has colA that is of type sql_variant and colB.
CREATE   TABLE tableA(colA sql_variant, colB int)  
INSERT INTO tableA values ( cast (46279.1 as decimal(8,2)), 1689)  
SELECT   SQL_VARIANT_PROPERTY(colA,'BaseType') AS 'Base Type',  
         SQL_VARIANT_PROPERTY(colA,'Precision') AS 'Precision',  
         SQL_VARIANT_PROPERTY(colA,'Scale') AS 'Scale'  
FROM      tableA  
WHERE      colB = 1689
go
Base Type    Precision    Scale  
---------    ---------    -----  
decimal      8           2  
  
(1 row(s) affected)

-- The following example retrieves SQL_VARIANT_PROPERTY information about a variable named @v1.
DECLARE @v1 sql_variant;  
SET @v1 = 'ABC';  
SELECT @v1;  
SELECT SQL_VARIANT_PROPERTY(@v1, 'BaseType');  
SELECT SQL_VARIANT_PROPERTY(@v1, 'MaxLength');
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Date and Time Data Types and Functions (Transact-SQL) ======================= -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>CURRENT_TIMESTAMP</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the current database system timestamp as a datetime value, without the database time zone offset. CURRENT_TIMESTAMP derives this value from the operating system of the computer on which the instance of SQL Server runs.</Description>
    <Syntax><![CDATA[<pre> CURRENT_TIMESTAMP </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/current-timestamp-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SYSDATETIME()  
    ,SYSDATETIMEOFFSET()  
    ,SYSUTCDATETIME()  
    ,CURRENT_TIMESTAMP  
    ,GETDATE()  
    ,GETUTCDATE();  
/* Returned:  
SYSDATETIME()      2007-04-30 13:10:02.0474381  
SYSDATETIMEOFFSET()2007-04-30 13:10:02.0474381 -07:00  
SYSUTCDATETIME()   2007-04-30 20:10:02.0474381  
CURRENT_TIMESTAMP  2007-04-30 13:10:02.047  
GETDATE()          2007-04-30 13:10:02.047  
GETUTCDATE()       2007-04-30 20:10:02.047  
*/
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CURRENT_TIMEZONE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the name of the time zone observed by a server or an instance. For SQL Database Managed Instance, return value is based on the time zone of the instance itself assigned during instance creation, not the time zone of the underlying operating system.</Description>
    <Syntax><![CDATA[<pre> CURRENT_TIMEZONE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/current-timezone-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT CURRENT_TIMEZONE(); /* Returned: (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna */ </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATEADD</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function adds a specified number value (as a signed integer) to a specified datepart of an input date value, and then returns that modified value. See Date and Time Data Types and Functions (Transact-SQL) for an overview of all Transact-SQL date and time data types and functions.</Description>
    <Syntax><![CDATA[<pre> DATEADD (datepart , number , date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/dateadd-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- datepart - The part of date to which DATEADD adds an integer number. This table lists all valid datepart arguments.
datepart	Abbreviations
----------- --------------
year        yy, yyyy
quarter     qq, q
month       mm, m
dayofyear   dy, y
day         dd, d
week        wk, ww
weekday     dw, w
hour        hh
minute      mi, n
second      ss, s
millisecond ms
microsecond mcs
nanosecond  ns
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATEDIFF</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the count (as a signed integer value) of the specified datepart boundaries crossed between the specified startdate and enddate. See DATEDIFF_BIG (Transact-SQL) for a function that handles larger differences between the startdate and enddate values. See Date and Time Data Types and Functions (Transact-SQL) for an overview of all Transact-SQL date and time data types and functions.</Description>
    <Syntax><![CDATA[<pre> DATEDIFF ( datepart , startdate , enddate ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datediff-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- datepart - The part of date to which DATEADD adds an integer number. This table lists all valid datepart arguments.
datepart	Abbreviations
----------- --------------
year        yy, yyyy
quarter     qq, q
month       mm, m
dayofyear   dy, y
day         dd, d
week        wk, ww
weekday     dw, w
hour        hh
minute      mi, n
second      ss, s
millisecond ms
microsecond mcs
nanosecond  ns

Examlpe:
SELECT DATEDIFF(year,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(quarter,     '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(month,       '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(dayofyear,   '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(day,         '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(week,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(hour,        '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(minute,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(second,      '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(millisecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
SELECT DATEDIFF(microsecond, '2005-12-31 23:59:59.9999999', '2006-01-01 00:00:00.0000000');
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATEDIFF_BIG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the count (as a signed big integer value) of the specified datepart boundaries crossed between the specified startdate and enddate. See Date and Time Data Types and Functions (Transact-SQL) for an overview of all Transact-SQL date and time data types and functions.</Description>
    <Syntax><![CDATA[<pre> DATEDIFF_BIG ( datepart , startdate , enddate ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datediff-big-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- datepart - The part of date to which DATEADD adds an integer number. This table lists all valid datepart arguments.
datepart	Abbreviations
----------- --------------
year        yy, yyyy
quarter     qq, q
month       mm, m
dayofyear   dy, y
day         dd, d
week        wk, ww
weekday     dw, w
hour        hh
minute      mi, n
second      ss, s
millisecond ms
microsecond mcs
nanosecond  ns
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATEFROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a date value that maps to the specified year, month, and day values.</Description>
    <Syntax><![CDATA[<pre> DATEFROMPARTS ( year, month, day ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datefromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT DATEFROMPARTS ( 2010, 12, 31 ) AS Result;

Result  
----------------------------------  
2010-12-31  
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATENAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a character string representing the specified datepart of the specified date.</Description>
    <Syntax><![CDATA[<pre> DATENAME ( datepart , date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datename-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- datepart - The part of date to which DATEADD adds an integer number. This table lists all valid datepart arguments.
datepart	Abbreviations
----------- --------------
year        yy, yyyy
quarter     qq, q
month       mm, m
dayofyear   dy, y
day         dd, d
week        wk, ww
weekday     dw, w
hour        hh
minute      mi, n
second      ss, s
millisecond ms
microsecond mcs
nanosecond  ns
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATEPART</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns an integer representing the specified datepart of the specified date.</Description>
    <Syntax><![CDATA[<pre> DATEPART ( datepart , date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datepart-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- datepart - The part of date to which DATEADD adds an integer number. This table lists all valid datepart arguments.
datepart	Abbreviations
----------- --------------
year        yy, yyyy
quarter     qq, q
month       mm, m
dayofyear   dy, y
day         dd, d
week        wk, ww
weekday     dw, w
hour        hh
minute      mi, n
second      ss, s
millisecond ms
microsecond mcs
nanosecond  ns
tzoffset    tz
iso_week    isowk, isoww
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATETIME2FROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a datetime2 value for the specified date and time arguments. The returned value has a precision specified by the precision argument.</Description>
    <Syntax><![CDATA[<pre> DATETIME2FROMPARTS ( year, month, day, hour, minute, seconds, fractions, precision ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datetime2fromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT DATETIME2FROMPARTS ( 2010, 12, 31, 23, 59, 59, 0, 0 ) AS Result;

Result  
---------------------------  
2010-12-31 23:59:59.0000000  
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATETIMEFROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a datetime value for the specified date and time arguments.</Description>
    <Syntax><![CDATA[<pre> DATETIMEFROMPARTS ( year, month, day, hour, minute, seconds, milliseconds ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datetimefromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT DATETIMEFROMPARTS ( 2010, 12, 31, 23, 59, 59, 0 ) AS Result;

Result  
---------------------------  
2010-12-31 23:59:59.000  
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATETIMEOFFSETFROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetimeoffset value for the specified date and time arguments. The returned value has a precision specified by the precision argument, and an offset as specified by the offset arguments.</Description>
    <Syntax><![CDATA[<pre> DATETIMEOFFSETFROMPARTS ( year, month, day, hour, minute, seconds, fractions, hour_offset, minute_offset, precision ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/datetimeoffsetfromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT DATETIMEOFFSETFROMPARTS ( 2010, 12, 31, 14, 23, 23, 0, 12, 0, 7 ) AS Result;

Result  
----------------------------------
2010-12-31 14:23:23.0000000 +12:00  
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DAY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns an integer that represents the day (day of the month) of the specified date.</Description>
    <Syntax><![CDATA[<pre> DAY ( date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/day-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- This statement returns 30 - the number of the day itself.
SELECT DAY('2015-04-30 01:01:01.1234567');
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>EOMONTH</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the last day of the month containing a specified date, with an optional offset.</Description>
    <Syntax><![CDATA[<pre> EOMONTH ( start_date [, month_to_add ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/eomonth-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @date DATETIME = '12/1/2011';  
SELECT EOMONTH ( @date ) AS Result;  
GO

Result  
------------  
2011-12-31  
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GETDATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the current database system timestamp as a datetime value without the database time zone offset. This value is derived from the operating system of the computer on which the instance of SQL Server is running.</Description>
    <Syntax><![CDATA[<pre> GETDATE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/getdate-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SYSDATETIME()  
    ,SYSDATETIMEOFFSET()  
    ,SYSUTCDATETIME()  
    ,CURRENT_TIMESTAMP  
    ,GETDATE()  
    ,GETUTCDATE();

-- Here is the result set.
SYSDATETIME()      2007-04-30 13:10:02.0474381
SYSDATETIMEOFFSET()2007-04-30 13:10:02.0474381 -07:00
SYSUTCDATETIME()   2007-04-30 20:10:02.0474381
CURRENT_TIMESTAMP  2007-04-30 13:10:02.047
GETDATE()          2007-04-30 13:10:02.047
GETUTCDATE()       2007-04-30 20:10:02.047
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GETUTCDATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the current database system timestamp as a datetime value. The database time zone offset is not included. This value represents the current UTC time (Coordinated Universal Time). This value is derived from the operating system of the computer on which the instance of SQL Server is running.</Description>
    <Syntax><![CDATA[<pre> GETUTCDATE() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/getutcdate-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT 'SYSDATETIME()      ', SYSDATETIME();  
SELECT 'SYSDATETIMEOFFSET()', SYSDATETIMEOFFSET();  
SELECT 'SYSUTCDATETIME()   ', SYSUTCDATETIME();  
SELECT 'CURRENT_TIMESTAMP  ', CURRENT_TIMESTAMP;  
SELECT 'GETDATE()          ', GETDATE();  
SELECT 'GETUTCDATE()       ', GETUTCDATE();  
/* Returned:  
SYSDATETIME()            2007-05-03 18:34:11.9351421  
SYSDATETIMEOFFSET()      2007-05-03 18:34:11.9351421 -07:00  
SYSUTCDATETIME()         2007-05-04 01:34:11.9351421  
CURRENT_TIMESTAMP        2007-05-03 18:34:11.933  
GETDATE()                2007-05-03 18:34:11.933  
GETUTCDATE()             2007-05-04 01:34:11.933  
*/
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ISDATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns 1 if the expression is a valid date, time, or datetime value; otherwise, 0. ISDATE returns 0 if the expression is a datetime2 value. For an overview of all Transact-SQL date and time data types and functions, see Date and Time Data Types and Functions (Transact-SQL). Note that the range for datetime data is 1753-01-01 through 9999-12-31, while the range for date data is 0001-01-01 through 9999-12-31.</Description>
    <Syntax><![CDATA[<pre> ISDATE ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/isdate-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
IF ISDATE('2009-05-12 10:19:41.177') = 1  
    PRINT 'VALID'  
ELSE  
    PRINT 'INVALID';
    
-- Showing the effects of the SET DATEFORMAT and SET LANGUAGE settings on return values
/* Use these sessions settings. */  
SET LANGUAGE us_english;  
SET DATEFORMAT mdy;  
/* Expression in mdy dateformat */  
SELECT ISDATE('04/15/2008'); --Returns 1.  
/* Expression in mdy dateformat */  
SELECT ISDATE('04-15-2008'); --Returns 1.   
/* Expression in mdy dateformat */  
SELECT ISDATE('04.15.2008'); --Returns 1.   
/* Expression in myd  dateformat */  
SELECT ISDATE('04/2008/15'); --Returns 1.  
  
SET DATEFORMAT mdy;  
SELECT ISDATE('15/04/2008'); --Returns 0.  
SET DATEFORMAT mdy;  
SELECT ISDATE('15/2008/04'); --Returns 0.  
SET DATEFORMAT mdy;  
SELECT ISDATE('2008/15/04'); --Returns 0.  
SET DATEFORMAT mdy;  
SELECT ISDATE('2008/04/15'); --Returns 1.  
  
SET DATEFORMAT dmy;  
SELECT ISDATE('15/04/2008'); --Returns 1.  
SET DATEFORMAT dym;  
SELECT ISDATE('15/2008/04'); --Returns 1.  
SET DATEFORMAT ydm;  
SELECT ISDATE('2008/15/04'); --Returns 1.  
SET DATEFORMAT ymd;  
SELECT ISDATE('2008/04/15'); --Returns 1.  
  
SET LANGUAGE English;  
SELECT ISDATE('15/04/2008'); --Returns 0.  
SET LANGUAGE Hungarian;  
SELECT ISDATE('15/2008/04'); --Returns 0.  
SET LANGUAGE Swedish;  
SELECT ISDATE('2008/15/04'); --Returns 0.  
SET LANGUAGE Italian;  
SELECT ISDATE('2008/04/15'); --Returns 1.  
  
/* Return to these sessions settings. */  
SET LANGUAGE us_english;  
SET DATEFORMAT mdy;
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>MONTH</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns an integer that represents the month of the specified date.</Description>
    <Syntax><![CDATA[<pre> MONTH ( date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/month-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following statement returns 4. This is the number of the month.
SELECT MONTH('2007-04-30T01:01:01.1234567 -07:00');
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SMALLDATETIMEFROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a smalldatetime value for the specified date and time.</Description>
    <Syntax><![CDATA[<pre> SMALLDATETIMEFROMPARTS ( year, month, day, hour, minute ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/smalldatetimefromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SMALLDATETIMEFROMPARTS ( 2010, 12, 31, 23, 59 ) AS Result

Result  
---------------------------  
2010-12-31 23:59:00  
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SWITCHOFFSET</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetimeoffset value that is changed from the stored time zone offset to a specified new time zone offset.</Description>
    <Syntax><![CDATA[<pre> SWITCHOFFSET ( DATETIMEOFFSET, time_zone ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/switchoffset-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
CREATE TABLE dbo.test   
    (  
    ColDatetimeoffset datetimeoffset  
    );  
GO  
INSERT INTO dbo.test   
VALUES ('1998-09-20 7:45:50.71345 -5:00');  
GO  
SELECT SWITCHOFFSET (ColDatetimeoffset, '-08:00')   
FROM dbo.test;  
GO  
--Returns: 1998-09-20 04:45:50.7134500 -08:00  
SELECT ColDatetimeoffset  
FROM dbo.test;  
--Returns: 1998-09-20 07:45:50.7134500 -05:00
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SYSDATETIME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetime2(7) value that contains the date and time of the computer on which the instance of SQL Server is running.</Description>
    <Syntax><![CDATA[<pre> SYSDATETIME ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sysdatetime-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SYSDATETIME()  
    ,SYSDATETIMEOFFSET()  
    ,SYSUTCDATETIME()  
    ,CURRENT_TIMESTAMP  
    ,GETDATE()  
    ,GETUTCDATE();  
/* Returned:  
SYSDATETIME()      2007-04-30 13:10:02.0474381  
SYSDATETIMEOFFSET()2007-04-30 13:10:02.0474381 -07:00  
SYSUTCDATETIME()   2007-04-30 20:10:02.0474381  
CURRENT_TIMESTAMP  2007-04-30 13:10:02.047  
GETDATE()          2007-04-30 13:10:02.047  
GETUTCDATE()       2007-04-30 20:10:02.047  
*/
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SYSDATETIMEOFFSET</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetimeoffset(7) value that contains the date and time of the computer on which the instance of SQL Server is running. The time zone offset is included.</Description>
    <Syntax><![CDATA[<pre> SYSDATETIMEOFFSET ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sysdatetimeoffset-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SYSDATETIME() AS [SYSDATETIME()]  
    ,SYSDATETIMEOFFSET() AS [SYSDATETIMEOFFSET()]  
    ,SYSUTCDATETIME() AS [SYSUTCDATETIME()]  
    ,CURRENT_TIMESTAMP AS [CURRENT_TIMESTAMP]  
    ,GETDATE() AS [GETDATE()]  
    ,GETUTCDATE() AS [GETUTCDATE()];
-- Results:
SYSDATETIME()      2007-04-30 13:10:02.0474381
SYSDATETIMEOFFSET()2007-04-30 13:10:02.0474381 -07:00
SYSUTCDATETIME()   2007-04-30 20:10:02.0474381
CURRENT_TIMESTAMP  2007-04-30 13:10:02.047
GETDATE()          2007-04-30 13:10:02.047
GETUTCDATE()       2007-04-30 20:10:02.047
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SYSUTCDATETIME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetime2 value that contains the date and time of the computer on which the instance of SQL Server is running. The date and time is returned as UTC time (Coordinated Universal Time). The fractional second precision specification has a range from 1 to 7 digits. The default precision is 7 digits.</Description>
    <Syntax><![CDATA[<pre> SYSUTCDATETIME ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sysutcdatetime-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SYSDATETIME() AS [SYSDATETIME()]  
    ,SYSDATETIMEOFFSET() AS [SYSDATETIMEOFFSET()]  
    ,SYSUTCDATETIME() AS [SYSUTCDATETIME()]  
    ,CURRENT_TIMESTAMP AS [CURRENT_TIMESTAMP]  
    ,GETDATE() AS [GETDATE()]  
    ,GETUTCDATE() AS [GETUTCDATE()];
-- Results:
SYSDATETIME()      2007-04-30 13:10:02.0474381
SYSDATETIMEOFFSET()2007-04-30 13:10:02.0474381 -07:00
SYSUTCDATETIME()   2007-04-30 20:10:02.0474381
CURRENT_TIMESTAMP  2007-04-30 13:10:02.047
GETDATE()          2007-04-30 13:10:02.047
GETUTCDATE()       2007-04-30 20:10:02.047
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TIMEFROMPARTS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a time value for the specified time and with the specified precision.</Description>
    <Syntax><![CDATA[<pre> TIMEFROMPARTS ( hour, minute, seconds, fractions, precision ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/timefromparts-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT TIMEFROMPARTS ( 23, 59, 59, 0, 0 ) AS Result;

Result  
--------------------  
23:59:59.0000000  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TODATETIMEOFFSET</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a datetimeoffset value that is translated from a datetime2 expression.</Description>
    <Syntax><![CDATA[<pre> TODATETIMEOFFSET ( expression , time_zone ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/todatetimeoffset-transact-sql?view=sql-server-ver15</SourceURL>
    <Example><![CDATA[<pre>
--------------------------------------------------------------
-- A. Changing the time zone offset of the current date and time
-- The following example changes the zone offset of the current date and time to time zone -07:00.
--------------------------------------------------------------
DECLARE @todaysDateTime datetime2;  
SET @todaysDateTime = GETDATE();  
SELECT TODATETIMEOFFSET (@todaysDateTime, '-07:00');  
-- RETURNS 2019-04-22 16:23:51.7666667 -07:00


--------------------------------------------------------------
-- B. Changing the time zone offset in minutes
-- The following example changes the current time zone to -120 minutes.
--------------------------------------------------------------
SELECT TODATETIMEOFFSET(SYSDATETIME(), -120)
-- RETURNS: 2019-04-22 11:39:21.6986813 -02:00


--------------------------------------------------------------
-- C. Adding a 13-hour time zone offset
-- The following example adds a 13-hour time zone offset to a date and time.
--------------------------------------------------------------
SELECT TODATETIMEOFFSET(SYSDATETIME(), '+13:00')
-- RETURNS: 2019-04-22 11:39:29.0339301 +13:00
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>xxx</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>xxx</Description>
    <Syntax><![CDATA[<pre> xxx </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/todatetimeoffset-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example changes the zone offset of the current date and time to time zone -07:00.
DECLARE @todaysDateTime datetime2;  
SET @todaysDateTime = GETDATE();  
SELECT TODATETIMEOFFSET (@todaysDateTime, '-07:00');  
-- RETURNS 2019-04-22 16:23:51.7666667 -07:00

-- The following example changes the current time zone to -120 minutes.
SELECT TODATETIMEOFFSET(SYSDATETIME(), -120)
-- RETURNS: 2019-04-22 11:39:21.6986813 -02:00

-- The following example adds a 13-hour time zone offset to a date and time.
SELECT TODATETIMEOFFSET(SYSDATETIME(), '+13:00')
-- RETURNS: 2019-04-22 11:39:29.0339301 +13:00
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>YEAR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns an integer that represents the year of the specified date.</Description>
    <Syntax><![CDATA[<pre> YEAR ( date ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/year-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following statement returns 2010. This is the number of the year.
SELECT YEAR('2010-04-30T01:01:01.1234567-07:00');
 </pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - JSON Functions (Transact-SQL) =============================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>ISJSON</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Tests whether a string contains valid JSON.</Description>
    <Syntax><![CDATA[<pre> ISJSON ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/isjson-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example runs a statement block conditionally if the parameter value @param contains valid JSON.
DECLARE @param <data type>
SET @param = <value>

IF (ISJSON(@param) > 0)  
BEGIN  
     -- Do something with the valid JSON value of @param.  
END

-- The following example returns rows in which the column json_col contains valid JSON.
SELECT id, json_col
FROM tab1
WHERE ISJSON(json_col) > 0
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>JSON_VALUE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Extracts a scalar value from a JSON string. To extract an object or an array from a JSON string instead of a scalar value, see JSON_QUERY (Transact-SQL). For info about the differences between JSON_VALUE and JSON_QUERY, see Compare JSON_VALUE and JSON_QUERY.</Description>
    <Syntax><![CDATA[<pre> JSON_VALUE ( expression , path ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/json-value-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example extracts the value of the JSON property town into a local variable.
DECLARE @jsonInfo NVARCHAR(MAX)
DECLARE @town NVARCHAR(32)

SET @jsonInfo=N'{"info":{"address":[{"town":"Paris"},{"town":"London"}]}}';

SET @town=JSON_VALUE(@jsonInfo,'$.info.address[0].town'); -- Paris
SET @town=JSON_VALUE(@jsonInfo,'$.info.address[1].town'); -- London

-- The following example creates computed columns based on the values of JSON properties.
CREATE TABLE dbo.Store
 (
  StoreID INT IDENTITY(1,1) NOT NULL,
  Address VARCHAR(500),
  jsonContent NVARCHAR(8000),
  Longitude AS JSON_VALUE(jsonContent, '$.address[0].longitude'),
  Latitude AS JSON_VALUE(jsonContent, '$.address[0].latitude')
 )
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>JSON_QUERY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Extracts an object or an array from a JSON string. To extract a scalar value from a JSON string instead of an object or an array, see JSON_VALUE (Transact-SQL). For info about the differences between JSON_VALUE and JSON_QUERY, see Compare JSON_VALUE and JSON_QUERY.</Description>
    <Syntax><![CDATA[<pre> JSON_QUERY ( expression [ , path ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/json-query-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example shows how to return a JSON fragment from a CustomFields column in query results.
SELECT PersonID,FullName,
 JSON_QUERY(CustomFields,'$.OtherLanguages') AS Languages
FROM Application.People

-- The following example shows how to include JSON fragments in the output of the FOR JSON clause.
SELECT StockItemID, StockItemName,
         JSON_QUERY(Tags) as Tags,
         JSON_QUERY(CONCAT('["',ValidFrom,'","',ValidTo,'"]')) ValidityPeriod
FROM Warehouse.StockItems
FOR JSON PATH
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>JSON_MODIFY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Updates the value of a property in a JSON string and returns the updated JSON string.</Description>
    <Syntax><![CDATA[<pre> JSON_MODIFY ( expression , path , newValue ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/json-modify-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @info NVARCHAR(100)='{"name":"John","skills":["C#","SQL"]}'
PRINT @info

-- Update name  
SET @info=JSON_MODIFY(@info,'$.name','Mike')
PRINT @info

-- Insert surname  
SET @info=JSON_MODIFY(@info,'$.surname','Smith')
PRINT @info

-- Delete name  
SET @info=JSON_MODIFY(@info,'$.name',NULL)
PRINT @info

-- Add skill  
SET @info=JSON_MODIFY(@info,'append $.skills','Azure')
PRINT @info

####################################################
Results:

{ "name": "John", "skills": ["C#", "SQL"] } 
{ "name": "Mike", "skills": ["C#", "SQL"] } 
{ "name": "Mike", "skills": ["C#", "SQL"], "surname": "Smith" } 
{ "skills": ["C#", "SQL"], "surname": "Smith" } 
{ "skills": ["C#", "SQL", "Azure"], "surname": "Smith" }
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Mathematical Functions (Transact-SQL) ======================================= -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>ABS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A mathematical function that returns the absolute (positive) value of the specified numeric expression. (ABS changes negative values to positive values. ABS has no effect on zero or positive values.)</Description>
    <Syntax><![CDATA[<pre> ABS ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/abs-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT ABS(-1.0), ABS(0.0), ABS(1.0);  -- returns: 1.0  .0   1.0 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ACOS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A function that returns the angle, in radians, whose cosine is the specified float expression. This is also called arccosine.</Description>
    <Syntax><![CDATA[<pre> ACOS ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/acos-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @cos float;  
SET @cos = -1.0;  
SELECT 'The ACOS of the number is: ' + CONVERT(varchar, ACOS(@cos));
-- The ACOS of the number is: 3.14159   
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ASIN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A function that returns the angle, in radians, whose sine is the specified float expression. This is also called arcsine.</Description>
    <Syntax><![CDATA[<pre> ASIN ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/asin-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
/* The first value will be -1.01. This fails because the value is   
outside the range.*/  
DECLARE @angle float  
SET @angle = -1.01  
SELECT 'The ASIN of the angle is: ' + CONVERT(varchar, ASIN(@angle))  
GO  
  
-- The next value is -1.00.  
DECLARE @angle float  
SET @angle = -1.00  
SELECT 'The ASIN of the angle is: ' + CONVERT(varchar, ASIN(@angle))  
GO  
  
-- The next value is 0.1472738.  
DECLARE @angle float  
SET @angle = 0.1472738  
SELECT 'The ASIN of the angle is: ' + CONVERT(varchar, ASIN(@angle))  
GO
##################################################
Returns:
-------------------------  
.Net SqlClient Data Provider: Msg 3622, Level 16, State 1, Line 3  
A domain error occurred.  
  
---------------------------------   
The ASIN of the angle is: -1.5708                          
  
(1 row(s) affected)  
  
----------------------------------   
The ASIN of the angle is: 0.147811                         
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ATAN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A function that returns the angle, in radians, whose tangent is a specified float expression. This is also called arctangent.</Description>
    <Syntax><![CDATA[<pre> ATAN ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/atan-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT 'The ATAN of -45.01 is: ' + CONVERT(varchar, ATAN(-45.01))  
SELECT 'The ATAN of -181.01 is: ' + CONVERT(varchar, ATAN(-181.01))  
SELECT 'The ATAN of 0 is: ' + CONVERT(varchar, ATAN(0))  
SELECT 'The ATAN of 0.1472738 is: ' + CONVERT(varchar, ATAN(0.1472738))  
SELECT 'The ATAN of 197.1099392 is: ' + CONVERT(varchar, ATAN(197.1099392))  
GO
-------------------------------   
The ATAN of -45.01 is: -1.54858                         
The ATAN of -181.01 is: -1.56527                         
The ATAN of 0 is: 0                                
The ATAN of 0.1472738 is: 0.146223                         
The ATAN of 197.1099392 is: 1.56572     
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ATN2</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x), where x and y are the values of the two specified float expressions.</Description>
    <Syntax><![CDATA[<pre> ATN2 ( float_expression , float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/atn2-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @x float = 35.175643, @y float = 129.44;  
SELECT 'The ATN2 of the angle is: ' + CONVERT(varchar, ATN2(@y, @x));  
GO

The ATN2 of the angle is: 1.30545                         
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CEILING</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the smallest integer greater than, or equal to, the specified numeric expression.</Description>
    <Syntax><![CDATA[<pre> CEILING ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ceiling-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT CEILING($123.45), CEILING($-123.45), CEILING($0.0);  
GO

--------- --------- -------------------------   
124.00    -123.00    0.00                       
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A mathematical function that returns the trigonometric cosine of the specified angle - measured in radians - in the specified expression.</Description>
    <Syntax><![CDATA[<pre> COS ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cos-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @angle float;  
SET @angle = 14.78;  
SELECT 'The COS of the angle is: ' + CONVERT(varchar,COS(@angle));  
GO
The COS of the angle is: -0.599465                        
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A mathematical function that returns the trigonometric cotangent of the specified angle - in radians - in the specified float expression.</Description>
    <Syntax><![CDATA[<pre> COT ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/cot-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @angle float;  
SET @angle = 124.1332;  
SELECT 'The COT of the angle is: ' + CONVERT(varchar,COT(@angle));  
GO
The COT of the angle is: -0.040312                
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DEGREES</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the corresponding angle, in degrees, for an angle specified in radians.</Description>
    <Syntax><![CDATA[<pre> DEGREES ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/degrees-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT 'The number of degrees in PI/2 radians is: ' +   
CONVERT(varchar, DEGREES((PI()/2)));  
GO
The number of degrees in PI/2 radians is 90         
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>EXP</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the exponential value of the specified float expression.</Description>
    <Syntax><![CDATA[<pre> EXP ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/exp-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @var float  
SET @var = 10  
SELECT 'The EXP of the variable is: ' + CONVERT(varchar,EXP(@var))  
GO
The EXP of the variable is: 22026.5  
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FLOOR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the largest integer less than or equal to the specified numeric expression.</Description>
    <Syntax><![CDATA[<pre> FLOOR ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/floor-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT FLOOR(123.45), FLOOR(-123.45), FLOOR($123.45);

---------      ---------     -----------  
123            -124          123.0000
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LOG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the natural logarithm of the specified float expression in SQL Server.</Description>
    <Syntax><![CDATA[<pre> LOG ( float_expression [, base ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/log-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @var float = 10;  
SELECT 'The LOG of the variable is: ' + CONVERT(varchar, LOG(@var));  
GO
The LOG of the variable is: 2.30259  
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LOG10</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the base-10 logarithm of the specified float expression.</Description>
    <Syntax><![CDATA[<pre> LOG10 ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/log10-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @var float;  
SET @var = 145.175643;  
SELECT 'The LOG10 of the variable is: ' + CONVERT(varchar,LOG10(@var));  
GO
The LOG10 of the variable is: 2.16189      
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PI</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the constant value of PI.</Description>
    <Syntax><![CDATA[<pre> PI ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/pi-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT PI();  -- returns: 3.14159265358979 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>POWER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the value of the specified expression to the specified power.</Description>
    <Syntax><![CDATA[<pre> POWER ( float_expression , y ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/power-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @input1 float;  
DECLARE @input2 float;  
SET @input1= 2;  
SET @input2 = 2.5;  
SELECT POWER(@input1, 3) AS Result1, POWER(@input2, 3) AS Result2;

Result1                Result2  
---------------------- ----------------------  
8                      15.625  
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>RADIANS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns radians when a numeric expression, in degrees, is entered.</Description>
    <Syntax><![CDATA[<pre> RADIANS ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/radians-transact-sql</SourceURL>
    <Example><![CDATA[<pre>
-- First value is -45.01.  
DECLARE @angle float  
SET @angle = -45.01  
SELECT 'The RADIANS of the angle is: ' +  
   CONVERT(varchar, RADIANS(@angle))  
GO  
-- Next value is -181.01.  
DECLARE @angle float  
SET @angle = -181.01  
SELECT 'The RADIANS of the angle is: ' +  
   CONVERT(varchar, RADIANS(@angle))  
GO  
-- Next value is 0.00.  
DECLARE @angle float  
SET @angle = 0.00  
SELECT 'The RADIANS of the angle is: ' +  
   CONVERT(varchar, RADIANS(@angle))  
GO  
-- Next value is 0.1472738.  
DECLARE @angle float  
SET @angle = 0.1472738  
SELECT 'The RADIANS of the angle is: ' +  
    CONVERT(varchar, RADIANS(@angle))  
GO  
-- Last value is 197.1099392.  
DECLARE @angle float  
SET @angle = 197.1099392  
SELECT 'The RADIANS of the angle is: ' +  
   CONVERT(varchar, RADIANS(@angle))  
GO

---------------------------------------   
The RADIANS of the angle is: -0.785573                        
(1 row(s) affected)  
---------------------------------------   
The RADIANS of the angle is: -3.15922                         
(1 row(s) affected)  
---------------------------------------   
The RADIANS of the angle is: 0                                
(1 row(s) affected)  
---------------------------------------   
The RADIANS of the angle is: 0.00257041                       
 (1 row(s) affected)  
---------------------------------------   
The RADIANS of the angle is: 3.44022                          
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>RAND</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a pseudo-random float value from 0 through 1, exclusive.</Description>
    <Syntax><![CDATA[<pre> RAND ( [ seed ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/rand-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT RAND(100), RAND(), RAND() </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ROUND</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a numeric value, rounded to the specified length or precision.</Description>
    <Syntax><![CDATA[<pre> ROUND ( numeric_expression , length [ ,function ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/round-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT ROUND(123.9994, 3), ROUND(123.9995, 3);  
GO

----------- -----------  
123.9990    124.0000
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SIGN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the positive (+1), zero (0), or negative (-1) sign of the specified expression.</Description>
    <Syntax><![CDATA[<pre> SIGN ( numeric_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sign-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @value real  
SET @value = -1  
WHILE @value < 2  
   BEGIN  
      SELECT SIGN(@value)  
      SET NOCOUNT ON  
      SELECT @value = @value + 1  
      SET NOCOUNT OFF  
   END  
SET NOCOUNT OFF  
GO

  
------------------------   
-1.0                       
  
(1 row(s) affected)  
  
------------------------   
0.0                        
  
(1 row(s) affected)  
  
------------------------   
1.0                        
  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SIN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the trigonometric sine of the specified angle, in radians, and in an approximate numeric, float, expression.</Description>
    <Syntax><![CDATA[<pre> SIN ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sin-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @angle float;  
SET @angle = 45.175643;  
SELECT 'The SIN of the angle is: ' + CONVERT(varchar,SIN(@angle));  
GO
The SIN of the angle is: 0.929607                         
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SQRT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the square root of the specified float value.</Description>
    <Syntax><![CDATA[<pre> SQRT ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sqrt-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @myvalue float;  
SET @myvalue = 1.00;  
WHILE @myvalue < 10.00  
   BEGIN  
      SELECT SQRT(@myvalue);  
      SET @myvalue = @myvalue + 1  
   END;  
GO

------------------------   
1.0                        
------------------------   
1.4142135623731            
------------------------   
1.73205080756888           
------------------------   
2.0                        
------------------------   
2.23606797749979           
------------------------   
2.44948974278318           
------------------------   
2.64575131106459           
------------------------   
2.82842712474619           
------------------------   
3.0
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SQUARE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the square of the specified float value.</Description>
    <Syntax><![CDATA[<pre> SQUARE ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/square-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
DECLARE @h float, @r float;  
SET @h = 5;  
SET @r = 1;  
SELECT PI()* SQUARE(@r)* @h AS 'Cyl Vol';

Cyl Vol  
--------------------------  
15.707963267948966
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TAN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the tangent of the input expression.</Description>
    <Syntax><![CDATA[<pre> TAN ( float_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/tan-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT TAN(PI()/2); --- returns: 1.6331778728383844E+16 </pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Logical Functions (Transact-SQL) ============================================ -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>CHOOSE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the item at the specified index from a list of values in SQL Server.</Description>
    <Syntax><![CDATA[<pre> CHOOSE ( index, val_1, val_2 [, val_n ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/logical-functions-choose-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT CHOOSE ( 3, 'Manager', 'Director', 'Developer', 'Tester' ) AS Result; -- returns: Developer </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IIF</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns one of two values, depending on whether the Boolean expression evaluates to true or false in SQL Server.</Description>
    <Syntax><![CDATA[<pre> IIF ( boolean_expression, true_value, false_value ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/logical-functions-iif-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @a int = 45, @b int = 40;  
SELECT IIF ( @a > @b, 'TRUE', 'FALSE' ) AS Result;
#############################################
Results:
Result  
--------  
TRUE  
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Metadata Functions  (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>APP_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the application name for the current session, if the application sets that name value</Description>
    <Syntax><![CDATA[<pre> APP_NAME() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/app-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
IF APP_NAME() = 'Microsoft SQL Server Management Studio - Query'  
PRINT 'This process was started by ' + APP_NAME() + '. The date is ' + CONVERT ( varchar(100) , GETDATE(), 101) + '.';  
ELSE   
PRINT 'This process was started by ' + APP_NAME() + '. The date is ' + CONVERT ( varchar(100) , GETDATE(), 102) + '.';  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>APPLOCK_MODE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the lock mode held by the lock owner on a particular application resource. As an application lock function, APPLOCK_MODE operates on the current database. The database is the scope of the application locks.</Description>
    <Syntax><![CDATA[<pre> APPLOCK_MODE( 'database_principal' , 'resource_name' , 'lock_owner' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/applock-mode-transact-sql</SourceURL>
    <Example><![CDATA[<pre> see the URL </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>APPLOCK_TEST</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns information as to whether or not a lock can be granted on a particular application resource, for a specified lock owner, without acquisition of the lock. As an application lock function, APPLOCK_TEST operates on the current database. The database is the scope of the application locks.</Description>
    <Syntax><![CDATA[<pre> APPLOCK_TEST ( 'database_principal' , 'resource_name' , 'lock_mode' , 'lock_owner' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/applock-test-transact-sql</SourceURL>
    <Example><![CDATA[<pre> see the URL </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ASSEMBLYPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns information about a property of an assembly</Description>
    <Syntax><![CDATA[<pre> ASSEMBLYPROPERTY('assembly_name', 'property_name') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/assemblyproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT ASSEMBLYPROPERTY ('HelloWorld' , 'PublicKey'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COL_LENGTH</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the defined length of a column, in bytes.</Description>
    <Syntax><![CDATA[<pre> COL_LENGTH ( 'table' , 'column' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/col-length-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
CREATE TABLE t1(c1 varchar(40), c2 nvarchar(40) );  
GO  
SELECT COL_LENGTH('t1','c1') AS 'VarChar',  
       COL_LENGTH('t1','c2') AS 'NVarChar';  
GO  
DROP TABLE t1;
#############################################
Results:
VarChar     NVarChar  
40          80
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COL_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the name of a table column, based on the table identification number and column identification number values of that table column.</Description>
    <Syntax><![CDATA[<pre> COL_NAME ( table_id , column_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/col-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select COL_NAME ( object_id('sys.databases') , 1 ) -- returns: name </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COLUMNPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns column or parameter information.</Description>
    <Syntax><![CDATA[<pre> COLUMNPROPERTY ( id , column , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/columnproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT COLUMNPROPERTY( OBJECT_ID('Person.Person'),'LastName','PRECISION')AS 'Column Length';  
GO
##########################################
Returns:
Column Length
-------------
50
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATABASEPROPERTYEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>For a specified database in SQL Server, this function returns the current setting of the specified database option or property.</Description>
    <Syntax><![CDATA[<pre> DATABASEPROPERTYEX ( database , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/databasepropertyex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT   
    DATABASEPROPERTYEX('AdventureWorks2014', 'Collation') AS Collation,  
    DATABASEPROPERTYEX('AdventureWorks2014', 'Edition') AS Edition,  
    DATABASEPROPERTYEX('AdventureWorks2014', 'ServiceObjective') AS ServiceObjective,  
    DATABASEPROPERTYEX('AdventureWorks2014', 'MaxSizeInBytes') AS MaxSizeInBytes
##########################################
Returns:
Collation                     Edition        ServiceObjective  MaxSizeInBytes  
----------------------------  -------------  ----------------  --------------  
SQL_Latin1_General_CP1_CI_AS  DataWarehouse  DW1000            5368709120
     </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DB_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the database identification (ID) number of a specified database.</Description>
    <Syntax><![CDATA[<pre> DB_ID ( [ 'database_name' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/db-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT DB_ID() AS [Database ID]; -- returns: 1 if in master database </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DB_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the name of a specified database.</Description>
    <Syntax><![CDATA[<pre> DB_NAME ( [ database_id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/db-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT DB_NAME() AS [Current Database]; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILE_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>For the given logical name for a component file of the current database, this function returns the file identification (ID) number.</Description>
    <Syntax><![CDATA[<pre> FILE_ID ( file_name ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/file-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT FILE_ID('AdventureWorks2012_Data')AS 'File ID'; 
go
##########################################
Returns:
File ID   
-------   
1  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILE_IDEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the file identification (ID) number for the specified logical name of a data, log, or full-text file of the current database.</Description>
    <Syntax><![CDATA[<pre> FILE_IDEX ( file_name ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/file-idex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT FILE_IDEX('AdventureWorks2012_Data') AS 'File ID';  
GO
##########################################
Returns:
File ID   
-------   
1  
(1 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILE_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the logical file name for a given file identification (ID) number.</Description>
    <Syntax><![CDATA[<pre> FILE_NAME ( file_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/file-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FILE_NAME(1) AS 'File Name 1', FILE_NAME(2) AS 'File Name 2';  
GO
##########################################
Returns:
File Name 1                File Name 2  
-------------------------  ------------------------  
AdventureWorks2012_Data    AdventureWorks2012_Log  

(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILEGROUP_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the filegroup identification (ID) number for a specified filegroup name.</Description>
    <Syntax><![CDATA[<pre> FILEGROUP_ID ( 'filegroup_name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/filegroup-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FILEGROUP_ID('PRIMARY') AS [Filegroup ID];  
GO
##########################################
Returns:
Filegroup ID  
------------  
1  

(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILEGROUP_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the filegroup name for the specified filegroup identification (ID) number.</Description>
    <Syntax><![CDATA[<pre> FILEGROUP_NAME ( filegroup_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/filegroup-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FILEGROUP_NAME(1) AS [Filegroup Name];  
GO
##########################################
Returns:
Filegroup Name   
-----------------------  
PRIMARY  
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILEGROUPPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the filegroup property value for a specified name and filegroup value.</Description>
    <Syntax><![CDATA[<pre> FILEGROUPPROPERTY ( filegroup_name, property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/filegroupproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FILEGROUPPROPERTY('PRIMARY', 'IsDefault') AS 'Default Filegroup';  
GO
 </pre>]]></Example>
##########################################
Returns:
Default Filegroup   
---------------------   
1  
  
(1 row(s) affected)
</Entry>

<Entry>
    <CmdName>FILEPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the specified file name property value when a file name in the current database and a property name are specified. Returns NULL for files that are not in the current database.</Description>
    <Syntax><![CDATA[<pre> FILEPROPERTY ( file_name , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/fileproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FILEPROPERTY('AdventureWorks2012_Data', 'IsPrimaryFile')AS [Primary File];  
GO
##########################################
Returns:
Primary File   
-------------  
1  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FILEPROPERTYEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the specified extended file property value when a file name in the current database and a property name are specified. Returns NULL for files that are not in the current database or for extended file properties that do not exist. Currently, extended file properties only apply to databases that are in Azure Blob storage.</Description>
    <Syntax><![CDATA[<pre> FILEPROPERTYEX ( name , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/filepropertyex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT s.file_id,
       s.type_desc,
       s.name,
       FILEPROPERTYEX(s.name, 'BlobTier') AS BlobTier,
       FILEPROPERTYEX(s.name, 'AccountType') AS AccountType,
       FILEPROPERTYEX(s.name, 'IsInferredTier') AS IsInferredTier,
       FILEPROPERTYEX(s.name, 'IsPageBlob') AS IsPageBlob
FROM sys.database_files AS s
WHERE s.type_desc IN ('ROWS', 'LOG');
##########################################
Returns:
file_id  type_desc  name  BlobTier  AccountType  IsInferredTier  IsPageBlob
--------------------------------------------------------------------------------------
1     ROWS      data_0  P30  PremiumBlobStorage  0   1
2     LOG       log     P30  PremiumBlobStorage  0   1

(2 rows affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FULLTEXTCATALOGPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about full-text catalog properties in SQL Server 2019 (15.x).</Description>
    <Syntax><![CDATA[<pre> FULLTEXTCATALOGPROPERTY ('catalog_name' ,'property') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/fulltextcatalogproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT fulltextcatalogproperty('Cat_Desc', 'ItemCount');  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FULLTEXTSERVICEPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information related to the properties of the Full-Text Engine. These properties can be set and retrieved by using sp_fulltext_service.</Description>
    <Syntax><![CDATA[<pre> FULLTEXTSERVICEPROPERTY ('property') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/fulltextserviceproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT fulltextserviceproperty('VerifySignature'); -- returns: 0 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>INDEX_COL</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the indexed column name. Returns NULL for XML indexes.</Description>
    <Syntax><![CDATA[<pre> INDEX_COL ( '[ database_name . [ schema_name ] .| schema_name ] table_or_view_name', index_id , key_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/index-col-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT   
    INDEX_COL (N'AdventureWorks2012.Sales.SalesOrderDetail', 1,1) AS  
        [Index Column 1],   
    INDEX_COL (N'AdventureWorks2012.Sales.SalesOrderDetail', 1,2) AS  
        [Index Column 2];  
GO
##########################################
Returns:
Index Column 1      Index Column 2  
-----------------------------------------------  
SalesOrderID        SalesOrderDetailID
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>INDEXKEY_PROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about the index key. Returns NULL for XML indexes.</Description>
    <Syntax><![CDATA[<pre> INDEXKEY_PROPERTY ( object_ID ,index_ID ,key_ID ,property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/indexkey-property-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT   
    INDEXKEY_PROPERTY(OBJECT_ID('Production.Location', 'U'),  
        1,1,'ColumnId') AS [Column ID],  
    INDEXKEY_PROPERTY(OBJECT_ID('Production.Location', 'U'),  
        1,1,'IsDescending') AS [Asc or Desc order];
##########################################
Returns:
Column ID   Asc or Desc order   
----------- -----------------   
1           0  
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>INDEXPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the named index or statistics property value of a specified table identification number, index or statistics name, and property name. Returns NULL for XML indexes.</Description>
    <Syntax><![CDATA[<pre> INDEXPROPERTY ( object_ID , index_or_statistics_name , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/indexproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT   
    INDEXPROPERTY(OBJECT_ID('HumanResources.Employee'),  
        'PK_Employee_BusinessEntityID','IsClustered')AS [Is Clustered],  
    INDEXPROPERTY(OBJECT_ID('HumanResources.Employee'),  
        'PK_Employee_BusinessEntityID','IndexDepth') AS [Index Depth],  
    INDEXPROPERTY(OBJECT_ID('HumanResources.Employee'),  
        'PK_Employee_BusinessEntityID','IndexFillFactor') AS [Fill Factor];
##########################################
Returns:
Is Clustered Index Depth Fill Factor   
------------ ----------- -----------   
1            2           0  
  
(1 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>NEXT VALUE FOR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Generates a sequence number from the specified sequence object. For a complete discussion of both creating and using sequences, see Sequence Numbers. Use sp_sequence_get_range to generate reserve a range of sequence numbers.</Description>
    <Syntax><![CDATA[<pre> NEXT VALUE FOR [ database_name . ] [ schema_name . ]  sequence_name [ OVER (<over_order_by_clause>) ] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/next-value-for-transact-sql</SourceURL>
    <Example><![CDATA[<pre> CREATE TABLE Test.TestTable  
     (CounterColumn int PRIMARY KEY,  
    Name nvarchar(25) NOT NULL) ;   
GO  
  
INSERT Test.TestTable (CounterColumn,Name)  
    VALUES (NEXT VALUE FOR Test.CountBy1, 'Syed') ;  
GO  
  
SELECT * FROM Test.TestTable;   
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECT_DEFINITION</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the Transact-SQL source text of the definition of a specified object.</Description>
    <Syntax><![CDATA[<pre> OBJECT_DEFINITION ( object_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/object-definition-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT OBJECT_DEFINITION (OBJECT_ID(N'Person.uAddress')) AS [Trigger Definition];   
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECT_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the database object identification number of a schema-scoped object.</Description>
    <Syntax><![CDATA[<pre> OBJECT_ID ( '[ database_name . [ schema_name ] . | schema_name . ] object_name' [ ,'object_type' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/object-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT OBJECT_ID(N'AdventureWorks2012.Production.WorkOrder') AS 'Object ID'; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECT_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the database object name for schema-scoped objects. For a list of schema-scoped objects, see sys.objects (Transact-SQL).</Description>
    <Syntax><![CDATA[<pre> OBJECT_NAME ( object_id [, database_id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/object-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT QUOTENAME(DB_NAME(database_id))   
    + N'.'   
    + QUOTENAME(OBJECT_SCHEMA_NAME(object_id, database_id))   
    + N'.'   
    + QUOTENAME(OBJECT_NAME(object_id, database_id))  
    , *   
FROM sys.dm_db_index_operational_stats(null, null, null, null);  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECT_SCHEMA_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the database schema name for schema-scoped objects. For a list of schema-scoped objects, see sys.objects (Transact-SQL).</Description>
    <Syntax><![CDATA[<pre> OBJECT_SCHEMA_NAME ( object_id [, database_id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/object-schema-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT DB_NAME(st.dbid) AS database_name,   
    OBJECT_SCHEMA_NAME(st.objectid, st.dbid) AS schema_name,  
    OBJECT_NAME(st.objectid, st.dbid) AS object_name,   
    st.text AS query_statement  
FROM sys.dm_exec_query_stats AS qs  
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st  
WHERE st.objectid IS NOT NULL;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECTPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about schema-scoped objects in the current database. For a list of schema-scoped objects, see sys.objects (Transact-SQL). This function cannot be used for objects that are not schema-scoped, such as data definition language (DDL) triggers and event notifications.</Description>
    <Syntax><![CDATA[<pre> OBJECTPROPERTY ( id , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/objectproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
IF OBJECTPROPERTY (OBJECT_ID(N'Production.UnitMeasure'),'ISTABLE') = 1  
   PRINT 'UnitMeasure is a table.'  
ELSE IF OBJECTPROPERTY (OBJECT_ID(N'Production.UnitMeasure'),'ISTABLE') = 0  
   PRINT 'UnitMeasure is not a table.'  
ELSE IF OBJECTPROPERTY (OBJECT_ID(N'Production.UnitMeasure'),'ISTABLE') IS NULL  
   PRINT 'ERROR: UnitMeasure is not a valid object.';  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OBJECTPROPERTYEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about schema-scoped objects in the current database. For a list of these objects, see sys.objects (Transact-SQL). OBJECTPROPERTYEX cannot be used for objects that are not schema-scoped, such as data definition language (DDL) triggers and event notifications.</Description>
    <Syntax><![CDATA[<pre> OBJECTPROPERTYEX ( id , property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/objectpropertyex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
CREATE SYNONYM MyEmployeeTable FOR HumanResources.Employee;  
GO  
SELECT OBJECTPROPERTYEX ( object_id(N'MyEmployeeTable'), N'BaseType')AS [Base Type];  
GO
##########################################
Returns:
Base Type 
--------  
U
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ORIGINAL_DB_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the database name specified by the user in the database connection string. This database is specified by using the sqlcmd-d option (USE database). It can also be specified with the Open Database Connectivity (ODBC) data source expression (initial catalog =databasename).</Description>
    <Syntax><![CDATA[<pre> ORIGINAL_DB_NAME () </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/original-db-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PARSENAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the specified part of an object name. The parts of an object that can be retrieved are the object name, owner name, database name, and server name.</Description>
    <Syntax><![CDATA[<pre> PARSENAME ( 'object_name' , object_piece ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/parsename-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -- Uses AdventureWorks  
  
SELECT PARSENAME('AdventureWorksPDW2012.dbo.DimCustomer', 1) AS 'Object Name',  
       PARSENAME('AdventureWorksPDW2012.dbo.DimCustomer', 2) AS 'Schema Name',  
       PARSENAME('AdventureWorksPDW2012.dbo.DimCustomer', 3) AS 'Database Name',  
       PARSENAME('AdventureWorksPDW2012.dbo.DimCustomer', 4) AS 'Server Name'
GO
##########################################
Returns:
Object Name                    Schema Name                    Database Name                  Server Name
------------------------------ ------------------------------ ------------------------------ ------------------------------
DimCustomer                    dbo                            AdventureWorksPDW2012          NULL
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SCHEMA_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the schema ID associated with a schema name.</Description>
    <Syntax><![CDATA[<pre> SCHEMA_ID ( [ schema_name ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/schema-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SCHEMA_ID('dbo'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SCHEMA_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the schema name associated with a schema ID.</Description>
    <Syntax><![CDATA[<pre> SCHEMA_NAME ( [ schema_id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/schema-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SCHEMA_NAME(1); -- returns: dbo </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SCOPE_IDENTITY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the last identity value inserted into an identity column in the same scope. A scope is a module: a stored procedure, trigger, function, or batch. Therefore, if two statements are in the same stored procedure, function, or batch, they are in the same scope.</Description>
    <Syntax><![CDATA[<pre> SCOPE_IDENTITY() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/scope-identity-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
INSERT INTO Person.ContactType ([Name]) VALUES ('Assistant to the Manager');  
GO  
SELECT SCOPE_IDENTITY() AS [SCOPE_IDENTITY];  
GO  
SELECT @@IDENTITY AS [@@IDENTITY];  
GO
##########################################
Returns:
SCOPE_IDENTITY  
21  
@@IDENTITY  
21
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SERVERPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns property information about the server instance.</Description>
    <Syntax><![CDATA[<pre> SERVERPROPERTY ( 'propertyname' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/serverproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT  
  SERVERPROPERTY('MachineName') AS ComputerName,
  SERVERPROPERTY('ServerName') AS InstanceName,  
  SERVERPROPERTY('Edition') AS Edition,
  SERVERPROPERTY('ProductVersion') AS ProductVersion,  
  SERVERPROPERTY('ProductLevel') AS ProductLevel;  
GO
##########################################
Returns:
+------------+------------+--------------------------+--------------+------------+
|ComputerName|InstanceName|Edition                   |ProductVersion|ProductLevel|
+------------+------------+--------------------------+--------------+------------+
|gorans-ub2  |gorans-ub2  |Developer Edition (64-bit)|14.0.3281.6   |RTM         |
+------------+------------+--------------------------+--------------+------------+
Rows 1
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STATS_DATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the date of the most recent update for statistics on a table or indexed view.</Description>
    <Syntax><![CDATA[<pre> STATS_DATE ( object_id , stats_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/stats-date-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the date of the most recent update for each statistics object on the Person.Address table.
USE AdventureWorks2012;  
GO  
SELECT name AS stats_name,   
    STATS_DATE(object_id, stats_id) AS statistics_update_date  
FROM sys.stats   
WHERE object_id = OBJECT_ID('Person.Address');  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TYPE_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the ID for a specified data type name.</Description>
    <Syntax><![CDATA[<pre> TYPE_ID ( [ schema_name ] type_name ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/type-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns type ID for single- and two-part type names.
USE tempdb;  
GO  
CREATE TYPE NewType FROM int;  
GO  
CREATE SCHEMA NewSchema;  
GO  
CREATE TYPE NewSchema.NewType FROM int;  
GO  
SELECT TYPE_ID('NewType') AS [1 Part Data Type ID],  
       TYPE_ID('NewSchema.NewType') AS [2 Part Data Type ID];  
GO
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TYPE_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the unqualified type name of a specified type ID.</Description>
    <Syntax><![CDATA[<pre> TYPE_NAME ( type_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/type-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT o.name AS obj_name, c.name AS col_name,  
       TYPE_NAME(c.user_type_id) AS type_name  
FROM sys.objects AS o   
JOIN sys.columns AS c  ON o.object_id = c.object_id  
WHERE o.name = 'Vendor'  
ORDER BY col_name;  
GO
##########################################
Returns:
obj_name        col_name                  type_name
--------------- ------------------------ --------------
Vendor          AccountNumber            AccountNumber
Vendor          ActiveFlag               Flag
Vendor          BusinessEntityID         int
Vendor          CreditRating             tinyint
Vendor          ModifiedDate             datetime
Vendor          Name                     Name
Vendor          PreferredVendorStatus    Flag
Vendor          PurchasingWebServiceURL  nvarchar

(8 row(s) affected)
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TYPEPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about a data type.</Description>
    <Syntax><![CDATA[<pre> TYPEPROPERTY (type , property) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/typeproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
-- The following example returns the owner of a data type.
SELECT TYPEPROPERTY(SCHEMA_NAME(schema_id) + '.' + name, 'OwnerId') AS owner_id, name, system_type_id, user_type_id, schema_id  
FROM sys.types;

-- The following example returns the precision or number of digits for the tinyint data type.
SELECT TYPEPROPERTY( 'tinyint', 'PRECISION');
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Ranking Functions  (Transact-SQL) =========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>DENSE_RANK</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the rank of each row within a result set partition, with no gaps in the ranking values. The rank of a specific row is one plus the number of distinct rank values that come before that specific row</Description>
    <Syntax><![CDATA[<pre> DENSE_RANK ( ) OVER ( [ <partition_by_clause> ] < order_by_clause > ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/dense-rank-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
USE AdventureWorks2012;  
GO  
SELECT i.ProductID, p.Name, i.LocationID, i.Quantity  
    ,DENSE_RANK() OVER   
    (PARTITION BY i.LocationID ORDER BY i.Quantity DESC) AS Rank  
FROM Production.ProductInventory AS i   
INNER JOIN Production.Product AS p   
    ON i.ProductID = p.ProductID  
WHERE i.LocationID BETWEEN 3 AND 4  
ORDER BY i.LocationID;  
GO
########################################################
Results:
ProductID   Name                               LocationID Quantity Rank  
----------- ---------------------------------- ---------- -------- -----  
494         Paint - Silver                     3          49       1  
495         Paint - Blue                       3          49       1  
493         Paint - Red                        3          41       2  
496         Paint - Yellow                     3          30       3  
492         Paint - Black                      3          17       4  
495         Paint - Blue                       4          35       1  
496         Paint - Yellow                     4          25       2  
493         Paint - Red                        4          24       3  
492         Paint - Black                      4          14       4  
494         Paint - Silver                     4          12       5  
  
(10 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>NTILE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Distributes the rows in an ordered partition into a specified number of groups. The groups are numbered, starting at one. For each row, NTILE returns the number of the group to which the row belongs</Description>
    <Syntax><![CDATA[<pre> NTILE (integer_expression) OVER ( [ <partition_by_clause> ] < order_by_clause > ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ntile-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
USE AdventureWorks2012;   
GO  
SELECT p.FirstName, p.LastName  
    ,NTILE(4) OVER(ORDER BY SalesYTD DESC) AS Quartile  
    ,CONVERT(nvarchar(20),s.SalesYTD,1) AS SalesYTD  
    , a.PostalCode  
FROM Sales.SalesPerson AS s   
INNER JOIN Person.Person AS p   
    ON s.BusinessEntityID = p.BusinessEntityID  
INNER JOIN Person.Address AS a   
    ON a.AddressID = p.BusinessEntityID  
WHERE TerritoryID IS NOT NULL   
    AND SalesYTD <> 0;  
GO
########################################################
Results:
FirstName      LastName              Quartile  SalesYTD       PostalCode  
-------------  --------------------- --------- -------------- ----------  
Linda          Mitchell              1         4,251,368.55   98027  
Jae            Pak                   1         4,116,871.23   98055  
Michael        Blythe                1         3,763,178.18   98027  
Jillian        Carson                1         3,189,418.37   98027  
Ranjit         Varkey Chudukatil     2         3,121,616.32   98055  
José           Saraiva               2         2,604,540.72   98055  
Shu            Ito                   2         2,458,535.62   98055  
Tsvi           Reiter                2         2,315,185.61   98027  
Rachel         Valdez                3         1,827,066.71   98055  
Tete           Mensa-Annan           3         1,576,562.20   98055  
David          Campbell              3         1,573,012.94   98055  
Garrett        Vargas                4         1,453,719.47   98027  
Lynn           Tsoflias              4         1,421,810.92   98055  
Pamela         Ansman-Wolfe          4         1,352,577.13   98027  

(14 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>RANK</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the rank of each row within the partition of a result set. The rank of a row is one plus the number of ranks that come before the row in question. ROW_NUMBER and RANK are similar. ROW_NUMBER numbers all rows sequentially (for example 1, 2, 3, 4, 5). RANK provides the same numeric value for ties (for example 1, 2, 2, 4, 5).</Description>
    <Syntax><![CDATA[<pre> RANK ( ) OVER ( [ partition_by_clause ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/rank-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
USE AdventureWorks2012;  
GO  
SELECT i.ProductID, p.Name, i.LocationID, i.Quantity  
    ,RANK() OVER   
    (PARTITION BY i.LocationID ORDER BY i.Quantity DESC) AS Rank  
FROM Production.ProductInventory AS i   
INNER JOIN Production.Product AS p   
    ON i.ProductID = p.ProductID  
WHERE i.LocationID BETWEEN 3 AND 4  
ORDER BY i.LocationID;  
GO
########################################################
Results:
ProductID   Name                   LocationID   Quantity Rank  
----------- ---------------------- ------------ -------- ----  
494         Paint - Silver         3            49       1  
495         Paint - Blue           3            49       1  
493         Paint - Red            3            41       3  
496         Paint - Yellow         3            30       4  
492         Paint - Black          3            17       5  
495         Paint - Blue           4            35       1  
496         Paint - Yellow         4            25       2  
493         Paint - Red            4            24       3  
492         Paint - Black          4            14       4  
494         Paint - Silver         4            12       5  
 (10 row(s) affected)
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ROW_NUMBER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Numbers the output of a result set. More specifically, returns the sequential number of a row within a partition of a result set, starting at 1 for the first row in each partition. ROW_NUMBER and RANK are similar. ROW_NUMBER numbers all rows sequentially (for example 1, 2, 3, 4, 5). RANK provides the same numeric value for ties (for example 1, 2, 2, 4, 5).</Description>
    <Syntax><![CDATA[<pre> ROW_NUMBER() OVER ( [ PARTITION BY value_expression , ... [ n ] ] order_by_clause ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/row-number-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT 
  ROW_NUMBER() OVER(ORDER BY name ASC) AS Row#,
  name, recovery_model_desc
FROM sys.databases 
WHERE database_id < 5;
go
########################################################
Results:
+----+------+-------------------+
|Row#|name  |recovery_model_desc|
+----+------+-------------------+
|1   |master|SIMPLE             |
|2   |model |FULL               |
|3   |msdb  |SIMPLE             |
|4   |tempdb|SIMPLE             |
+----+------+-------------------+
Rows 4


=======================================================
SELECT 
  ROW_NUMBER() OVER(PARTITION BY recovery_model_desc ORDER BY name ASC) 
    AS Row#,
  name, recovery_model_desc
FROM sys.databases WHERE database_id < 5;
go
########################################################
Results:
+----+------+-------------------+
|Row#|name  |recovery_model_desc|
+----+------+-------------------+
|1   |model |FULL               |
|1   |master|SIMPLE             |
|2   |msdb  |SIMPLE             |
|3   |tempdb|SIMPLE             |
+----+------+-------------------+
Rows 4

 </pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Replication Functions  (Transact-SQL) ======================================= -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>PUBLISHINGSERVERNAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the name of the originating Publisher for a published database participating in a database mirroring session. This function is executed at a Publisher instance of SQL Server on the publication database. Use it to determine the original Publisher of the published database</Description>
    <Syntax><![CDATA[<pre> PUBLISHINGSERVERNAME() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/replication-functions-publishingservername</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Rowset Functions  (Transact-SQL) ============================================ -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>OPENDATASOURCE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Provides ad hoc connection information as part of a four-part object name without using a linked server name.</Description>
    <Syntax><![CDATA[<pre> OPENDATASOURCE ( 'provider_name', 'init_string' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/opendatasource-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT *  
FROM OPENDATASOURCE('SQLNCLI',  
    'Data Source=London\Payroll;Integrated Security=SSPI')  
    .AdventureWorks2012.HumanResources.Employee; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OPENJSON</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>OPENJSON is a table-valued function that parses JSON text and returns objects and properties from the JSON input as rows and columns. In other words, OPENJSON provides a rowset view over a JSON document. You can explicitly specify the columns in the rowset and the JSON property paths used to populate the columns. Since OPENJSON returns a set of rows, you can use OPENJSON in the FROM clause of a Transact-SQL statement just as you can use any other table, view, or table-valued function. Use OPENJSON to import JSON data into SQL Server, or to convert JSON data to relational format for an app or service that can't consume JSON directly.</Description>
    <Syntax><![CDATA[<pre> OPENJSON( jsonExpression [ , path ] )  [ <with_clause> ] <with_clause> ::= WITH ( { colName type [ column_path ] [ AS JSON ] } [ ,...n ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/openjson-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @json1 NVARCHAR(MAX),@json2 NVARCHAR(MAX)

SET @json1=N'{"name": "John", "surname":"Doe"}'
SET @json2=N'{"name": "John", "age":45}'

SELECT *
FROM OPENJSON(@json1)
UNION ALL
SELECT *
FROM OPENJSON(@json2)
WHERE [key] NOT IN (SELECT [key] FROM OPENJSON(@json1)) </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OPENQUERY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Executes the specified pass-through query on the specified linked server. This server is an OLE DB data source. OPENQUERY can be referenced in the FROM clause of a query as if it were a table name. OPENQUERY can also be referenced as the target table of an INSERT, UPDATE, or DELETE statement. This is subject to the capabilities of the OLE DB provider. Although the query may return multiple result sets, OPENQUERY returns only the first one</Description>
    <Syntax><![CDATA[<pre> OPENQUERY ( linked_server ,'query' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/openquery-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT * FROM OPENQUERY (OracleSvr, 'SELECT name FROM joe.titles WHERE name = ''NewTitle'''); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OPENROWSET</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>ncludes all connection information that is required to access remote data from an OLE DB data source. This method is an alternative to accessing tables in a linked server and is a one-time, ad hoc method of connecting and accessing remote data by using OLE DB. For more frequent references to OLE DB data sources, use linked servers instead. For more information, see Linked Servers (Database Engine). The OPENROWSET function can be referenced in the FROM clause of a query as if it were a table name. The OPENROWSET function can also be referenced as the target table of an INSERT, UPDATE, or DELETE statement, subject to the capabilities of the OLE DB provider. Although the query might return multiple result sets, OPENROWSET returns only the first one. OPENROWSET also supports bulk operations through a built-in BULK provider that enables data from a file to be read and returned as a rowset.</Description>
    <Syntax><![CDATA[<pre> OPENROWSET('providerName', 'connProps', 'sql-query') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/openrowset-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT a.*
FROM OPENROWSET('SQLNCLI', 'Server=Seattle1;Trusted_Connection=yes;',
     'SELECT GroupName, Name, DepartmentID
      FROM AdventureWorks2012.HumanResources.Department
      ORDER BY GroupName, Name') AS a; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>OPENXML</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>OPENXML provides a rowset view over an XML document. Because OPENXML is a rowset provider, OPENXML can be used in Transact-SQL statements in which rowset providers such as a table, view, or the OPENROWSET function can appear.</Description>
    <Syntax><![CDATA[<pre> OPENXML( idoc int [ in] , rowpattern nvarchar [ in ] , [ flags byte [ in ] ] ) [ WITH ( SchemaDeclaration | TableName ) ] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/openxml-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @idoc int, @doc varchar(1000);  
SET @doc ='  
<ROOT>  
<Customer CustomerID="VINET" ContactName="Paul Henriot">  
   <Order CustomerID="VINET" EmployeeID="5" OrderDate="1996-07-04T00:00:00">  
      <OrderDetail OrderID="10248" ProductID="11" Quantity="12"/>  
      <OrderDetail OrderID="10248" ProductID="42" Quantity="10"/>  
   </Order>  
</Customer>  
<Customer CustomerID="LILAS" ContactName="Carlos Gonzlez">  
   <Order CustomerID="LILAS" EmployeeID="3" OrderDate="1996-08-16T00:00:00">  
      <OrderDetail OrderID="10283" ProductID="72" Quantity="3"/>  
   </Order>  
</Customer>  
</ROOT>';  
--Create an internal representation of the XML document.  
EXEC sp_xml_preparedocument @idoc OUTPUT, @doc;  
-- Execute a SELECT statement that uses the OPENXML rowset provider.  
SELECT    *  
FROM       OPENXML (@idoc, '/ROOT/Customer',1)  
            WITH (CustomerID  varchar(10),  
                  ContactName varchar(20));
</pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Security Functions  (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>CERTENCODED</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the public portion of a certificate in binary format. This function takes a certificate ID as an argument, and returns the encoded certificate. To create a new certificate, pass the binary result to CREATE CERTIFICATE ... WITH BINARY.</Description>
    <Syntax><![CDATA[<pre> CERTENCODED ( cert_id ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/certencoded-transact-sql</SourceURL>
    <Example><![CDATA[<pre> CREATE DATABASE TEST1;
GO
USE TEST1
CREATE CERTIFICATE Shipping04
ENCRYPTION BY PASSWORD = 'pGFD4bb925DGvbd2439587y'
WITH SUBJECT = 'Sammamish Shipping Records',
EXPIRY_DATE = '20401031';
GO
SELECT CERTENCODED(CERT_ID('Shipping04')); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CERTPRIVATEKEY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the private key of a certificate in binary format.</Description>
    <Syntax><![CDATA[<pre> CERTPRIVATEKEY(cert_ID, 'encryption_password' [, ' decryption_password ']) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/certprivatekey-transact-sql</SourceURL>
    <Example><![CDATA[<pre> CREATE DATABASE TEST1;  
GO  
USE TEST1  
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'Use 5tr0ng P^55Words'  
GO  
CREATE CERTIFICATE Shipping04   
WITH SUBJECT = 'Sammamish Shipping Records',   
EXPIRY_DATE = '20401031';  
GO  
SELECT CERTPRIVATEKEY(CERT_ID('Shipping04'), 'jklalkaa/; uia3dd'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CURRENT_USER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the name of the current user. This function is equivalent to USER_NAME()</Description>
    <Syntax><![CDATA[<pre> CURRENT_USER </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/current-user-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT CURRENT_USER </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DATABASE_PRINCIPAL_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the ID number of a principal in the current database. See Principals (Database Engine) for more information about principals</Description>
    <Syntax><![CDATA[<pre> DATABASE_PRINCIPAL_ID ( 'principal_name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/database-principal-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT DATABASE_PRINCIPAL_ID() </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>HAS_DBACCESS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about whether the user has access to the specified database</Description>
    <Syntax><![CDATA[<pre> HAS_DBACCESS ( 'database_name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/has-dbaccess-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT HAS_DBACCESS('AdventureWorks2012') </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>HAS_PERMS_BY_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Evaluates the effective permission of the current user on a securable. A related function is fn_my_permissions.</Description>
    <Syntax><![CDATA[<pre> HAS_PERMS_BY_NAME ( securable , securable_class , permission [ , sub-securable ] [ , sub-securable_class ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/has-perms-by-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT HAS_PERMS_BY_NAME(null, null, 'VIEW SERVER STATE') -- Do I have the server-level VIEW SERVER STATE permission?
SELECT HAS_PERMS_BY_NAME('Ps', 'LOGIN', 'IMPERSONATE')    -- Am I able to IMPERSONATE server principal Ps?
SELECT HAS_PERMS_BY_NAME(db_name(), 'DATABASE', 'ANY')    -- Do I have any permissions in the current database
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IS_MEMBER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Indicates whether the current user is a member of the specified Microsoft Windows group or SQL Server database role. The IS_MEMBER function is not supported for Azure Active Directory Groups</Description>
    <Syntax><![CDATA[<pre> IS_MEMBER ( { 'group' | 'role' } ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/is-member-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -- Test membership in db_owner and print appropriate message.  
IF IS_MEMBER ('db_owner') = 1  
   PRINT 'Current user is a member of the db_owner role'  
ELSE IF IS_MEMBER ('db_owner') = 0  
   PRINT 'Current user is NOT a member of the db_owner role'  
ELSE IF IS_MEMBER ('db_owner') IS NULL  
   PRINT 'ERROR: Invalid group / role specified';  
GO  
  
-- Execute SELECT if user is a member of ADVWORKS\Shipping.  
IF IS_MEMBER ('ADVWORKS\Shipping') = 1  
   SELECT 'User ' + USER + ' is a member of ADVWORKS\Shipping.';   
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IS_ROLEMEMBER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Indicates whether a specified database principle is a member of the specified database role.</Description>
    <Syntax><![CDATA[<pre> IS_ROLEMEMBER ( 'role' [ , 'database_principal' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/is-rolemember-transact-sql</SourceURL>
    <Example><![CDATA[<pre> IF IS_ROLEMEMBER ('db_datareader') = 1  
   print 'Current user is a member of the db_datareader role'  
ELSE IF IS_ROLEMEMBER ('db_datareader') = 0  
   print 'Current user is NOT a member of the db_datareader role'  
ELSE IF IS_ROLEMEMBER ('db_datareader') IS NULL  
   print 'ERROR: The database role specified is not valid.'; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>IS_SRVROLEMEMBER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Indicates whether a SQL Server login is a member of the specified server role.</Description>
    <Syntax><![CDATA[<pre> IS_SRVROLEMEMBER ( 'role' [ , 'login' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/is-srvrolemember-transact-sql</SourceURL>
    <Example><![CDATA[<pre> IF IS_SRVROLEMEMBER ('sysadmin') = 1  
   print 'Current user''s login is a member of the sysadmin role'  
ELSE IF IS_SRVROLEMEMBER ('sysadmin') = 0  
   print 'Current user''s login is NOT a member of the sysadmin role'  
ELSE IF IS_SRVROLEMEMBER ('sysadmin') IS NULL  
   print 'ERROR: The server role specified is not valid.'; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LOGINPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns information about login policy settings</Description>
    <Syntax><![CDATA[<pre> LOGINPROPERTY ( 'login_name' , 'property_name' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/loginproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT LOGINPROPERTY('John3', 'IsMustChange');   -- Checking whether a login must change its password
SELECT LOGINPROPERTY('John3', 'IsLocked');       -- Checking whether a login is locked out
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ORIGINAL_LOGIN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the name of the login that connected to the instance of SQL Server. You can use this function to return the identity of the original login in sessions in which there are many explicit or implicit context switches</Description>
    <Syntax><![CDATA[<pre> ORIGINAL_LOGIN( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/original-login-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
--Create a temporary login and user.  
CREATE LOGIN login1 WITH PASSWORD = 'J345#$)thb';  
CREATE USER user1 FOR LOGIN login1;  
GO  
--Execute a context switch to the temporary login account.  
DECLARE @original_login sysname;  
DECLARE @current_context sysname;  
EXECUTE AS LOGIN = 'login1';  
SET @original_login = ORIGINAL_LOGIN();  
SET @current_context = SUSER_SNAME();  
SELECT 'The current executing context is: '+ @current_context;  
SELECT 'The original login in this session was: '+ @original_login  
GO  
-- Return to the original execution context  
-- and remove the temporary principal.  
REVERT;  
GO  
DROP LOGIN login1;  
DROP USER user1;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PERMISSIONS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a value containing a bitmap that indicates the statement, object, or column permissions of the current user.</Description>
    <Syntax><![CDATA[<pre> PERMISSIONS ( [ objectid [ , 'column' ] ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/permissions-transact-sql</SourceURL>
    <Example><![CDATA[<pre> IF PERMISSIONS()&2=2  
   CREATE TABLE test_table (col1 INT)  
ELSE  
   PRINT 'ERROR: The current user cannot create a table.'; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PWDENCRYPT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the SQL Server password hash of the input value that uses the current version of the password hashing algorithm. PWDENCRYPT is an older function and might not be supported in a future release of SQL Server. Use HASHBYTES instead. HASHBYTES provides more hashing algorithms.</Description>
    <Syntax><![CDATA[<pre> PWDENCRYPT ( 'password' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/pwdencrypt-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PWDCOMPARE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Hashes a password and compares the hash to the hash of an existing password. PWDCOMPARE can be used to search for blank SQL Server login passwords or common weak passwords</Description>
    <Syntax><![CDATA[<pre> PWDCOMPARE ( 'clear_text_password', password_hash [, version ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/pwdcompare-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT name FROM sys.sql_logins WHERE PWDCOMPARE('', password_hash) = 1         -- Identifying logins that have no passwords
SELECT name FROM sys.sql_logins WHERE PWDCOMPARE('password', password_hash) = 1 -- Searching for common passwords
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SESSION_USER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>SESSION_USER returns the user name of the current context in the current database.</Description>
    <Syntax><![CDATA[<pre> SESSION_USER </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/session-user-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @session_usr nchar(30);  
SET @session_usr = SESSION_USER;  
SELECT 'This session''s current user is: '+ @session_usr;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SESSIONPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the SET options settings of a session</Description>
    <Syntax><![CDATA[<pre> SESSIONPROPERTY (option) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/sessionproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SESSIONPROPERTY('CONCAT_NULL_YIELDS_NULL') </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUSER_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the login identification number of the user</Description>
    <Syntax><![CDATA[<pre> SUSER_ID ( [ 'login' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SUSER_ID('sa'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUSER_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the login identification name of the user.</Description>
    <Syntax><![CDATA[<pre> SUSER_NAME ( [ server_user_id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SUSER_NAME(1); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUSER_SID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the security identification number (SID) for the specified login name.</Description>
    <Syntax><![CDATA[<pre> SUSER_SID ( [ 'login' ] [ , Param2 ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-sid-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT SUSER_SID(); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUSER_SNAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the login name associated with a security identification number (SID).</Description>
    <Syntax><![CDATA[<pre> SUSER_SNAME ( [ server_user_sid ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/suser-sname-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT SUSER_SNAME();   -- The following example returns the login name for the current security context
SELECT SUSER_SNAME(0x010500000000000515000000a065cf7e784b9b5fe77c87705a2e0000); -- The following example returns the login name associated with a Windows security identification number.
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SYSTEM_USER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Allows a system-supplied value for the current login to be inserted into a table when no default value is specified.</Description>
    <Syntax><![CDATA[<pre> SYSTEM_USER </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/system-user-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @sys_usr char(30);  
SET @sys_usr = SYSTEM_USER;  
SELECT 'The current system user is: '+ @sys_usr;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>USER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Allows a system-supplied value for the database user name of the current user to be inserted into a table when no default value is specified.</Description>
    <Syntax><![CDATA[<pre> xxx </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/user-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @usr char(30)  
SET @usr = user  
SELECT 'The current user''s database username is: '+ @usr  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>USER_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the identification number for a database user.</Description>
    <Syntax><![CDATA[<pre> USER_ID ( [ 'user' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/user-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT USER_ID('Harold'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>USER_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a database user name from a specified identification number.</Description>
    <Syntax><![CDATA[<pre> USER_NAME ( [ id ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/user-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT USER_NAME(13); -- The following example returns the user name for user ID 13.
SELECT USER_NAME();   -- The following example finds the name of the current user without specifying an ID.
 </pre>]]></Example>
</Entry>

<!-- ============================================================================================ -->
<!-- == FUNCTIONS - String Functions ============================================================ -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>ASCII</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the ASCII code value of the leftmost character of a character expression.</Description>
    <Syntax><![CDATA[<pre> ASCII ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ascii-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT ASCII('A') AS A, ASCII('B') AS B, ASCII('a') AS a, ASCII('b') AS b, ASCII(1) AS [1], ASCII(2) AS [2];  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CHAR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function converts an int ASCII code to a character value</Description>
    <Syntax><![CDATA[<pre> CHAR ( integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/char-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT CHAR(65) AS [65], CHAR(66) AS [66], CHAR(97) AS [97], CHAR(98) AS [98], CHAR(49) AS [49], CHAR(50) AS [50];  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CHARINDEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function searches for one character expression inside a second character expression, returning the starting position of the first expression if found</Description>
    <Syntax><![CDATA[<pre> CHARINDEX ( expressionToFind , expressionToSearch [ , start_location ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/charindex-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT CHARINDEX ( 'Test', 'This is a Test' COLLATE Latin1_General_CS_AS);  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CONCAT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a string resulting from the concatenation, or joining, of two or more string values in an end-to-end manner. (To add a separating value during concatenation, see CONCAT_WS.)</Description>
    <Syntax><![CDATA[<pre> CONCAT ( string_value1, string_value2 [, string_valueN ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/concat-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT CONCAT ( 'Happy ', 'Birthday ', 11, '/', '25' ) AS Result;  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CONCAT_WS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a string resulting from the concatenation, or joining, of two or more string values in an end-to-end manner. It separates those concatenated string values with the delimiter specified in the first function argument. (CONCAT_WS indicates concatenate with separator.)</Description>
    <Syntax><![CDATA[<pre> CONCAT_WS ( separator, argument1, argument2 [, argumentN]... ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/concat-ws-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT STRING_AGG(CONCAT_WS( ',', database_id, recovery_model_desc, containment_desc), char(13)) AS DatabaseInfo FROM sys.databases  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DIFFERENCE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns an integer value measuring the difference between the SOUNDEX() values of two different character expressions.</Description>
    <Syntax><![CDATA[<pre> DIFFERENCE ( character_expression , character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/difference-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  -- Returns a DIFFERENCE value of 4, the least possible difference.  
SELECT SOUNDEX('Green'), SOUNDEX('Greene'), DIFFERENCE('Green','Greene');  
GO  
-- Returns a DIFFERENCE value of 0, the highest possible difference.  
SELECT SOUNDEX('Blotchet-Halls'), SOUNDEX('Greene'), DIFFERENCE('Blotchet-Halls', 'Greene');  
GO  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FORMAT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a value formatted with the specified format and optional culture. Use the FORMAT function for locale-aware formatting of date/time and number values as strings. For general data type conversions, use CAST or CONVERT.</Description>
    <Syntax><![CDATA[<pre> FORMAT ( value, format [, culture ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/format-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  select FORMAT(CAST('2018-01-01 14:00' AS datetime2), N'HH:mm') -- returns 14:00  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LEFT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the left part of a character string with the specified number of characters.</Description>
    <Syntax><![CDATA[<pre> LEFT ( character_expression , integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/left-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT LEFT('abcdefg',2);  -- returns 'ab'  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LEN</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the number of characters of the specified string expression, excluding trailing spaces</Description>
    <Syntax><![CDATA[<pre> LEN ( string_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/len-transact-sql</SourceURL>
    <Example><![CDATA[/pre>  SELECT LEN(FirstName) AS Length, FirstName, LastName   
FROM Sales.vIndividualCustomer  
WHERE CountryRegionName = 'Australia';  
GO  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LOWER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a character expression after converting uppercase character data to lowercase</Description>
    <Syntax><![CDATA[<pre> LOWER ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/lower-transact-sql</SourceURL>
    <Example><![CDATA[<pre>   -- Uses AdventureWorks  
  
SELECT LOWER(SUBSTRING(EnglishProductName, 1, 20)) AS Lower,   
       UPPER(SUBSTRING(EnglishProductName, 1, 20)) AS Upper,   
       LOWER(UPPER(SUBSTRING(EnglishProductName, 1, 20))) As LowerUpper  
FROM dbo.DimProduct  
WHERE ListPrice between 11.00 and 20.00; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>LTRIM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a character expression after it removes leading blanks.</Description>
    <Syntax><![CDATA[<pre> LTRIM ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/ltrim-transact-sql</SourceURL>
    <Example><![CDATA[<pre>  SELECT LTRIM('     Five spaces are at the beginning of this string.') FROM sys.databases;  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>NCHAR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the Unicode character with the specified integer code, as defined by the Unicode standard.</Description>
    <Syntax><![CDATA[<pre> NCHAR ( integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/nchar-transact-sql</SourceURL>
    <Example><![CDATA[<pre> CREATE DATABASE test COLLATE Finnish_Swedish_100_CS_AS_SC;  
DECLARE @d nvarchar(10) = N'𣅿';
-- Old style method.  
SELECT NCHAR(0xD84C) + NCHAR(0xDD7F);   
  
-- Preferred method.   
SELECT NCHAR(143743);   
  
-- Alternative preferred method.  
SELECT NCHAR(UNICODE(@d)); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>PATINDEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the starting position of the first occurrence of a pattern in a specified expression, or zeros if the pattern is not found, on all valid text and character data types</Description>
    <Syntax><![CDATA[<pre> PATINDEX ( '%pattern%' , expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/patindex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT position = PATINDEX('%ter%', 'interesting data'); -- returns: 3 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>QUOTENAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a Unicode string with the delimiters added to make the input string a valid SQL Server delimited identifier.</Description>
    <Syntax><![CDATA[<pre> QUOTENAME ( 'character_string' [ , 'quote_character' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/quotename-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT QUOTENAME('abc[]def'); -- returns: [abc[]]def] </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>REPLACE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Replaces all occurrences of a specified string value with another string value</Description>
    <Syntax><![CDATA[<pre> REPLACE ( string_expression , string_pattern , string_replacement ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/replace-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT REPLACE('abcdefghicde','cde','xxx');  -- returns: abxxxfghixxx </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>REPLICATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Repeats a string value a specified number of times.</Description>
    <Syntax><![CDATA[<pre> REPLICATE ( string_expression ,integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/replicate-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select REPLICATE('abc,', 4) -- returns: abc,abc,abc,abc, </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>REVERSE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the reverse order of a string value</Description>
    <Syntax><![CDATA[<pre> REVERSE ( string_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/reverse-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select REVERSE('abc') -- returns: cba </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>RIGHT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the right part of a character string with the specified number of characters.</Description>
    <Syntax><![CDATA[<pre> RIGHT ( character_expression , integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/right-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT RIGHT('abcdefg', 2) -- returns: fg </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>RTRIM </CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a character string after truncating all trailing spaces</Description>
    <Syntax><![CDATA[<pre> RTRIM ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/rtrim-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT RTRIM('Removes trailing spaces.   '); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SOUNDEX</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a four-character (SOUNDEX) code to evaluate the similarity of two strings</Description>
    <Syntax><![CDATA[<pre> SOUNDEX ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/soundex-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -- SELECT SOUNDEX ('Smith'), SOUNDEX ('Smythe'); -- returns: S530 & S530 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SPACE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a string of repeated spaces</Description>
    <Syntax><![CDATA[<pre> SPACE ( integer_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/space-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select 'aaa' + SPACE(2) + 'bbb' -- returns: aaa  bbb </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns character data converted from numeric data. The character data is right-justified, with a specified length and decimal precision</Description>
    <Syntax><![CDATA[<pre> STR ( float_expression [ , length [ , decimal ] ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/str-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT STR(123.45, 6, 1); -- returns: 123.5 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STRING_AGG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Concatenates the values of string expressions and places separator values between them. The separator is not added at the end of string</Description>
    <Syntax><![CDATA[<pre> STRING_AGG ( expression, separator ) [ WITHIN GROUP ( ORDER BY <order_by_expression_list> [ ASC | DESC ] ) ] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/string-agg-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select STRING_AGG(name, ';') from sys.databases -- RETURNS: master;tempdb;model;msdb  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STRING_ESCAPE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Escapes special characters in texts and returns text with escaped characters. STRING_ESCAPE is a deterministic function, introduced in SQL Server 2016</Description>
    <Syntax><![CDATA[<pre> STRING_ESCAPE( text , type ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/string-escape-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select FORMATMESSAGE('{ "id": %d,"name": "%s", "type": "%s" }', 123, STRING_ESCAPE('Vinyl','json'), STRING_ESCAPE('12"','json') ); -- returns: { "id": 123, "name": "Vinyl", "type": "12\""} </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STRING_SPLIT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A table-valued function that splits a string into rows of substrings, based on a specified separator character.</Description>
    <Syntax><![CDATA[<pre> STRING_SPLIT ( string , separator ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT value FROM STRING_SPLIT('Lorem ipsum dolor sit amet.', ' ');
Returns:
+-----+
|value|
+-----+
|Lorem|
|ipsum|
|dolor|
|sit  |
|amet.|
+-----+
Rows 5
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>STUFF</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>The STUFF function inserts a string into another string. It deletes a specified length of characters in the first string at the start position and then inserts the second string into the first string at the start position</Description>
    <Syntax><![CDATA[<pre> STUFF ( character_expression , start , length , replaceWith_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/stuff-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT STUFF('abcdef', 2, 3, 'ijklmn'); -- returns: aijklmnef </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SUBSTRING</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns part of a character, binary, text, or image expression in SQL Server</Description>
    <Syntax><![CDATA[<pre> SUBSTRING ( expression ,start , length ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/substring-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT x = SUBSTRING('abcdef', 2, 3); -- returns: bcd </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRANSLATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the string provided as a first argument after some characters specified in the second argument are translated into a destination set of characters specified in the third argument</Description>
    <Syntax><![CDATA[<pre> TRANSLATE ( inputString, characters, translations) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/translate-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT TRANSLATE('2*[3+4]/{7-2}', '[]{}', '()()'); -- returns: 2*(3+4)/(7-2) </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRIM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Removes the space character char(32) or other specified characters from the start and end of a string</Description>
    <Syntax><![CDATA[<pre> TRIM ( [ characters FROM ] string ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/trim-transact-sql</SourceURL>
    <Example><![CDATA[<pre> 
SELECT TRIM( '     test    ') AS Result;                     -- returns: 'test' 
SELECT TRIM( '.,! ' FROM  '     #     test    .') AS Result; -- returns: '#     test'
</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>UNICODE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the integer value, as defined by the Unicode standard, for the first character of the input expression.</Description>
    <Syntax><![CDATA[<pre> UNICODE ( 'ncharacter_expression' ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/unicode-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DECLARE @nstring nchar(12);  
SET @nstring = N'Åkergatan 24';  
SELECT UNICODE(@nstring), NCHAR(UNICODE(@nstring));

returns:
+---+-+
|   | |
+---+-+
|197|Å|
+---+-+
Rows 1
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>UPPER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a character expression with lowercase character data converted to uppercase.</Description>
    <Syntax><![CDATA[<pre> UPPER ( character_expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/upper-transact-sql</SourceURL>
    <Example><![CDATA[<pre> select upper('aaa') -- returns: AAA </pre>]]></Example>
</Entry>

<!-- ============================================================================================ -->
<!-- == FUNCTIONS - System Functions ============================================================ -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>$PARTITION</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the partition number into which a set of partitioning column values would be mapped for any specified partition function in SQL Server 2019 (15.x).</Description>
    <Syntax><![CDATA[<pre> [ database_name. ] $PARTITION.partition_function_name(expression) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/partition-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
CREATE PARTITION FUNCTION RangePF1 ( int )  
AS RANGE FOR VALUES (10, 100, 1000) ;  
GO  
SELECT $PARTITION.RangePF1 (10) ;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>BINARY_CHECKSUM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the binary checksum value computed over a row of a table or over a list of expressions</Description>
    <Syntax><![CDATA[<pre> BINARY_CHECKSUM ( * | expression [ ,...n ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/binary-checksum-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
CREATE TABLE myTable (column1 int, column2 varchar(256));  
GO  
INSERT INTO myTable VALUES (1, 'test');  
GO  
SELECT BINARY_CHECKSUM(*) from myTable;  
GO  
UPDATE myTable set column2 = 'TEST';  
GO  
SELECT BINARY_CHECKSUM(*) from myTable;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CHECKSUM</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>The CHECKSUM function returns the checksum value computed over a table row, or over an expression list. Use CHECKSUM to build hash indexes.</Description>
    <Syntax><![CDATA[<pre> CHECKSUM ( * | expression [ ,...n ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/checksum-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -- Create a checksum index.  

SET ARITHABORT ON;  
USE AdventureWorks2012;   
GO  
ALTER TABLE Production.Product  
ADD cs_Pname AS CHECKSUM(Name);  
GO  
CREATE INDEX Pname_index ON Production.Product (cs_Pname);  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>COMPRESS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function compresses the input expression, using the GZIP algorithm. The function returns a byte array of type varbinary(max).</Description>
    <Syntax><![CDATA[<pre> COMPRESS ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/compress-transact-sql</SourceURL>
    <Example><![CDATA[<pre> DELETE FROM player  
OUTPUT deleted.id, deleted.name, deleted.surname, deleted.datemodifier, COMPRESS(deleted.info)   
INTO dbo.inactivePlayers
WHERE datemodified < @startOfYear; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CONNECTIONPROPERTY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>For a request that comes in to the server, this function returns information about the connection properties of the unique connection which supports that request</Description>
    <Syntax><![CDATA[<pre> CONNECTIONPROPERTY ( property ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/connectionproperty-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT   
ConnectionProperty('net_transport') AS 'Net transport',   
ConnectionProperty('protocol_type') AS 'Protocol type'; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CONTEXT_INFO</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the context_info value either set for the current session or batch, or derived through use of the SET CONTEXT_INFO statement</Description>
    <Syntax><![CDATA[<pre> CONTEXT_INFO() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/context-info-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SET CONTEXT_INFO 0x1256698456;  
GO  
SELECT CONTEXT_INFO();  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CURRENT_REQUEST_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the ID of the current request within the current session</Description>
    <Syntax><![CDATA[<pre> CURRENT_REQUEST_ID() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/current-request-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>CURRENT_TRANSACTION_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the transaction ID of the current transaction in the current session</Description>
    <Syntax><![CDATA[<pre> CURRENT_TRANSACTION_ID( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/current-transaction-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT CURRENT_TRANSACTION_ID(); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>DECOMPRESS</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function will decompress an input expression value, using the GZIP algorithm. DECOMPRESS will return a byte array (VARBINARY(MAX) type).</Description>
    <Syntax><![CDATA[<pre> DECOMPRESS ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/decompress-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT _id, name, surname, datemodified,  
             CAST(DECOMPRESS(info) AS NVARCHAR(MAX)) AS info  
FROM player; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_LINE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the line number of occurrence of an error that caused the CATCH block of a TRY...CATCH construct to execute.</Description>
    <Syntax><![CDATA[<pre> ERROR_LINE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-line-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Generate a divide-by-zero error.  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_LINE() AS ErrorLine;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_MESSAGE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the message text of the error that caused the CATCH block of a TRY...CATCH construct to execute.</Description>
    <Syntax><![CDATA[<pre> ERROR_MESSAGE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-message-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Generate a divide-by-zero error.  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_MESSAGE() AS ErrorMessage;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_NUMBER</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the error number of the error that caused the CATCH block of a TRY...CATCH construct to execute.</Description>
    <Syntax><![CDATA[<pre> ERROR_NUMBER ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-number-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Generate a divide-by-zero error.  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_NUMBER() AS ErrorNumber;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_PROCEDURE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the name of the stored procedure or trigger where an error occurs, if that error caused the CATCH block of a TRY...CATCH construct to execute</Description>
    <Syntax><![CDATA[<pre> ERROR_PROCEDURE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-procedure-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Execute the stored procedure inside the TRY block.  
    EXECUTE usp_ExampleProc;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_PROCEDURE() AS ErrorProcedure;  
END CATCH;  
 </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_SEVERITY</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns the severity value of the error where an error occurs, if that error caused the CATCH block of a TRY...CATCH construct to execute</Description>
    <Syntax><![CDATA[<pre> ERROR_SEVERITY ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-severity-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Generate a divide-by-zero error.  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_SEVERITY() AS ErrorSeverity;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ERROR_STATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the state number of the error that caused the CATCH block of a TRY...CATCH construct to be run.</Description>
    <Syntax><![CDATA[<pre> ERROR_STATE ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/error-state-transact-sql</SourceURL>
    <Example><![CDATA[<pre> BEGIN TRY  
    -- Generate a divide by zero error  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT ERROR_STATE() AS ErrorState;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>FORMATMESSAGE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>xConstructs a message from an existing message in sys.messages or from a provided string. The functionality of FORMATMESSAGE resembles that of the RAISERROR statement. However, RAISERROR prints the message immediately, while FORMATMESSAGE returns the formatted message for further processing.</Description>
    <Syntax><![CDATA[<pre> FORMATMESSAGE ( { msg_number  | ' msg_string ' } , [ param_value [ ,...n ] ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/formatmessage-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT FORMATMESSAGE('This is the %s and this is the %s.', 'first variable', 'second variable') AS Result; </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GET_FILESTREAM_TRANSACTION_CONTEXT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a token that represents the current transaction context of a session. The token is used by an application to bind FILESTREAM file-system streaming operations to the transaction. For a list of FILESTREAM topics, see Binary Large Object (Blob) Data (SQL Server).</Description>
    <Syntax><![CDATA[<pre> GET_FILESTREAM_TRANSACTION_CONTEXT () </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/get-filestream-transaction-context-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>GETANSINULL</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the default nullability for the database for this session.</Description>
    <Syntax><![CDATA[<pre> GETANSINULL ( [ 'database' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/getansinull-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT GETANSINULL('AdventureWorks2012') </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>HOST_ID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the workstation identification number. The workstation identification number is the process ID (PID) of the application on the client computer that is connecting to SQL Server</Description>
    <Syntax><![CDATA[<pre> HOST_ID () </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/host-id-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>HOST_NAME</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the workstation name</Description>
    <Syntax><![CDATA[<pre> HOST_NAME () </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/host-name-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ISNULL</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Replaces NULL with the specified replacement value</Description>
    <Syntax><![CDATA[<pre> ISNULL ( check_expression , replacement_value ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql</SourceURL>
    <Example><![CDATA[<pre> SELECT AVG(ISNULL(Weight, 50)) FROM Production.Product;  </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ISNUMERIC</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Determines whether an expression is a valid numeric type</Description>
    <Syntax><![CDATA[<pre> ISNUMERIC ( expression ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/isnumeric-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
SELECT City, PostalCode  
FROM Person.Address   
WHERE ISNUMERIC(PostalCode)<> 1;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>MIN_ACTIVE_ROWVERSION</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the lowest active rowversion value in the current database. A rowversion value is active if it is used in a transaction that has not yet been committed. For more information, see rowversion (Transact-SQL).</Description>
    <Syntax><![CDATA[<pre> MIN_ACTIVE_ROWVERSION </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/min-active-rowversion-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>NEWID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Creates a unique value of type uniqueidentifier</Description>
    <Syntax><![CDATA[<pre> NEWID ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/newid-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -- Creating a local variable with DECLARE/SET syntax.  
DECLARE @myid uniqueidentifier  
SET @myid = NEWID()  
PRINT 'Value of @myid is: '+ CONVERT(varchar(255), @myid) </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>NEWSEQUENTIALID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Creates a GUID that is greater than any GUID previously generated by this function on a specified computer since Windows was started. After restarting Windows, the GUID can start again from a lower range, but is still globally unique. When a GUID column is used as a row identifier, using NEWSEQUENTIALID can be faster than using the NEWID function. This is because the NEWID function causes random activity and uses fewer cached data pages. Using NEWSEQUENTIALID also helps to completely fill the data and index pages</Description>
    <Syntax><![CDATA[<pre> NEWSEQUENTIALID ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/newsequentialid-transact-sql</SourceURL>
    <Example><![CDATA[<pre> CREATE TABLE myTable (ColumnA uniqueidentifier DEFAULT NEWSEQUENTIALID()); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>ROWCOUNT_BIG</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the number of rows affected by the last statement executed. This function operates like @@ROWCOUNT, except the return type of ROWCOUNT_BIG is bigint</Description>
    <Syntax><![CDATA[<pre> ROWCOUNT_BIG ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/rowcount-big-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>SESSION_CONTEXT</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the value of the specified key in the current session context. The value is set by using the sp_set_session_context (Transact-SQL) procedure</Description>
    <Syntax><![CDATA[<pre> SESSION_CONTEXT(N'key') </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/session-context-transact-sql</SourceURL>
    <Example><![CDATA[<pre> EXEC sp_set_session_context 'user_id', 4;  
SELECT SESSION_CONTEXT(N'user_id'); </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>XACT_STATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Is a scalar function that reports the user transaction state of a current running request. XACT_STATE indicates whether the request has an active user transaction, and whether the transaction is capable of being committed.</Description>
    <Syntax><![CDATA[<pre> XACT_STATE() </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/xact-state-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
  
-- SET XACT_ABORT ON will render the transaction uncommittable  
-- when the constraint violation occurs.  
SET XACT_ABORT ON;  
  
BEGIN TRY  
    BEGIN TRANSACTION;  
        -- A FOREIGN KEY constraint exists on this table. This   
        -- statement will generate a constraint violation error.  
        DELETE FROM Production.Product  
            WHERE ProductID = 980;  
  
    -- If the delete operation succeeds, commit the transaction. The CATCH  
    -- block will not execute.  
    COMMIT TRANSACTION;  
END TRY  
BEGIN CATCH  
    -- Test XACT_STATE for 0, 1, or -1.  
    -- If 1, the transaction is committable.  
    -- If -1, the transaction is uncommittable and should   
    --     be rolled back.  
    -- XACT_STATE = 0 means there is no transaction and  
    --     a commit or rollback operation would generate an error.  
  
    -- Test whether the transaction is uncommittable.  
    IF (XACT_STATE()) = -1  
    BEGIN  
        PRINT 'The transaction is in an uncommittable state.' +  
              ' Rolling back transaction.'  
        ROLLBACK TRANSACTION;  
    END;  
  
    -- Test whether the transaction is active and valid.  
    IF (XACT_STATE()) = 1  
    BEGIN  
        PRINT 'The transaction is committable.' +   
              ' Committing transaction.'  
        COMMIT TRANSACTION;     
    END;  
END CATCH;  
GO </pre>]]></Example>
</Entry>

<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Text and Image Functions  (Transact-SQL) ==================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>TEXTPTR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>TEXTPTR ( column )</Description>
    <Syntax><![CDATA[<pre> xxx </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/text-and-image-functions-textptr-transact-sql</SourceURL>
    <Example><![CDATA[<pre> -none- </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TEXTVALID</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>A text, ntext, or image function that checks whether a specific text pointer is valid</Description>
    <Syntax><![CDATA[<pre> TEXTVALID ( 'table.column' ,text_ ptr ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/text-and-image-functions-textvalid-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Trigger  Functions  (Transact-SQL) ========================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>COLUMNS_UPDATED</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns a varbinary bit pattern indicating the inserted or updated columns of a table or view. Use COLUMNS_UPDATED anywhere inside the body of a Transact-SQL INSERT or UPDATE trigger to test whether the trigger should execute certain actions.</Description>
    <Syntax><![CDATA[<pre> COLUMNS_UPDATED ( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/columns-updated-transact-sql</SourceURL>
    <Example><![CDATA[<pre> none </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>EVENTDATA</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>This function returns information about server or database events. When an event notification fires, and the specified service broker receives the results, EVENTDATA is called. A DDL or logon trigger also support internal use of EVENTDATA.</Description>
    <Syntax><![CDATA[<pre> EVENTDATA( ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/eventdata-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
CREATE TRIGGER safety   
ON DATABASE   
FOR CREATE_TABLE   
AS   
    PRINT 'CREATE TABLE Issued.'  
    SELECT EVENTDATA().value  
        ('(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]','nvarchar(max)')  
   RAISERROR ('New tables cannot be created in this database.', 16, 1)   
   ROLLBACK  
;  
GO  
--Test the trigger.  
CREATE TABLE NewTable (Column1 int);  
GO  
--Drop the trigger.  
DROP TRIGGER safety  
ON DATABASE;  
GO </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>TRIGGER_NESTLEVEL</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns the number of triggers executed for the statement that fired the trigger. TRIGGER_NESTLEVEL is used in DML and DDL triggers to determine the current level of nesting</Description>
    <Syntax><![CDATA[<pre> TRIGGER_NESTLEVEL ( [ object_id ] , [ 'trigger_type' ] , [ 'trigger_event_category' ] ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/trigger-nestlevel-transact-sql</SourceURL>
    <Example><![CDATA[<pre> IF ( (SELECT trigger_nestlevel() ) > 5 )  
   RAISERROR('This statement nested over 5 levels of triggers.',16,-1) </pre>]]></Example>
</Entry>

<Entry>
    <CmdName>UPDATE</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Returns a Boolean value that indicates whether an INSERT or UPDATE attempt was made on a specified column of a table or view. UPDATE() is used anywhere inside the body of a Transact-SQL INSERT or UPDATE trigger to test whether the trigger should execute certain actions.</Description>
    <Syntax><![CDATA[<pre> UPDATE ( column ) </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/functions/update-trigger-functions-transact-sql</SourceURL>
    <Example><![CDATA[<pre> USE AdventureWorks2012;  
GO  
IF EXISTS (SELECT name FROM sys.objects  
      WHERE name = 'reminder' AND type = 'TR')  
   DROP TRIGGER Person.reminder;  
GO  
CREATE TRIGGER reminder  
ON Person.Address  
AFTER UPDATE   
AS   
IF ( UPDATE (StateProvinceID) OR UPDATE (PostalCode) )  
BEGIN  
RAISERROR (50009, 16, 10)  
END;  
GO  
-- Test the trigger.  
UPDATE Person.Address  
SET PostalCode = 99999  
WHERE PostalCode = '12345';  
GO </pre>]]></Example>
</Entry>


<!-- ============================================================================================ -->
<!-- == FUNCTIONS - Some extra added by gorans ================================================== -->
<!-- ============================================================================================ -->
<Entry>
    <CmdName>RAISERROR</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Generates an error message and initiates error processing for the session. RAISERROR can either reference a user-defined message stored in the sys.messages catalog view or build a message dynamically. The message is returned as a server error message to the calling application or to an associated CATCH block of a TRY...CATCH construct. New applications should use THROW instead.</Description>
    <Syntax><![CDATA[<pre> RAISERROR ({msg_id|msg_str|@local_variable}, severity, state [,argument [,...n]]) [WITH option {LOG|NOWAIT|SETERROR}] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/language-elements/raiserror-transact-sql?view=sql-server-ver15</SourceURL>
    <Example><![CDATA[<pre>
------------------------------------------------------------------------------
-- Simple: Msg: 50000, Severity: 16, State: 1 
------------------------------------------------------------------------------
RAISERROR('Some text', 16, 1)  
RAISERROR('Some text', 16, 1) WITH NOWAIT -- flushes the message to the client


------------------------------------------------------------------------------
-- Simple, error message 50000 with parameters
------------------------------------------------------------------------------
RAISERROR(N'This is message %s %d.',  -- Message text.  
           10,                        -- Severity,  
           1,                         -- State,  
           N'number',                 -- First argument.  
           5);                        -- Second argument.  
-- The message text returned is: This is message number 5.  
GO


------------------------------------------------------------------------------
-- Simple, error message 50000, mesasge in a variable, with parameters
------------------------------------------------------------------------------
DECLARE @msg nvarchar(512);  
SET @msg = N'<\<%7.3s>>';  
  
RAISERROR(@msg,       -- Message text.  
           10,        -- Severity,  
           1,         -- State,  
           N'abcde'); -- First argument supplies the string.  
-- The message text returned is: <<    abc>>.  
GO  


------------------------------------------------------------------------------
-- Returning error information from a CATCH block
------------------------------------------------------------------------------
BEGIN TRY  
    -- RAISERROR with severity 11-19 will cause execution to   
    -- jump to the CATCH block.  
    RAISERROR ('Error raised in TRY block.', -- Message text.  
               16, -- Severity.  
               1 -- State.  
               );  
END TRY  
BEGIN CATCH  
    DECLARE @ErrorMessage NVARCHAR(4000);  
    DECLARE @ErrorSeverity INT;  
    DECLARE @ErrorState INT;  
  
    SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE();  
  
    -- Use RAISERROR inside the CATCH block to return error  
    -- information about the original error that caused  
    -- execution to jump to the CATCH block.  
    RAISERROR (@ErrorMessage, -- Message text.  
               @ErrorSeverity, -- Severity.  
               @ErrorState -- State.  
               );  
END CATCH;  

</pre>]]></Example>
</Entry>

<Entry>
    <CmdName>THROW</CmdName>
    <Module>Transact-SQL: Functions</Module>
    <Description>Raises an exception and transfers execution to a CATCH block of a TRY...CATCH construct in SQL Server 2019 (15.x).</Description>
    <Syntax><![CDATA[<pre> THROW [ { error_number | @local_variable }, { message | @local_variable }, { state | @local_variable } ] </pre>]]></Syntax>
    <SourceURL>https://docs.microsoft.com/en-us/sql/t-sql/language-elements/throw-transact-sql?view=sql-server-ver15</SourceURL>
    <Example><![CDATA[<pre>
------------------------------------------------------------------------------
-- A. Using THROW to raise an exception
------------------------------------------------------------------------------
THROW 51000, 'The record does not exist.', 1;  

Msg 51000, Level 16, State 1, Line 1  
The record does not exist.


------------------------------------------------------------------------------
-- B. Using THROW to raise an exception again
------------------------------------------------------------------------------
USE tempdb;  
GO  
CREATE TABLE dbo.TestRethrow  
(    ID INT PRIMARY KEY  
);  
BEGIN TRY  
    INSERT dbo.TestRethrow(ID) VALUES(1);  
--  Force error 2627, Violation of PRIMARY KEY constraint to be raised.  
    INSERT dbo.TestRethrow(ID) VALUES(1);  
END TRY  
BEGIN CATCH  
  
    PRINT 'In catch block.';  
    THROW;  
END CATCH;  

--- RESULTS -----------------------
In catch block. 
Msg 2627, Level 14, State 1, Line 1  
Violation of PRIMARY KEY constraint 'PK__TestReth__3214EC272E3BD7D3'. Cannot insert duplicate key in object 'dbo.TestRethrow'.  
The statement has been terminated.


------------------------------------------------------------------------------
-- C. Using FORMATMESSAGE with THROW
-- The following example shows how to use the FORMATMESSAGE function with THROW to throw a customized error message. The example first creates a user-defined error message by using sp_addmessage. Because the THROW statement does not allow for substitution parameters in the message parameter in the way that RAISERROR does, the FORMATMESSAGE function is used to pass the three parameter values expected by error message 60000.
------------------------------------------------------------------------------
EXEC sys.sp_addmessage  
     @msgnum   = 60000  
    ,@severity = 16  
    ,@msgtext  = N'This is a test message with one numeric parameter (%d), one string parameter (%s), and another string parameter (%s).'  
    ,@lang = 'us_english';
GO
  
DECLARE @msg NVARCHAR(2048) = FORMATMESSAGE(60000, 500, N'First string', N'second string');
THROW 60000, @msg, 1;

--- RESULTS -----------------------
Msg 60000, Level 16, State 1, Line 2  
This is a test message with one numeric parameter (500), one string parameter (First string), and another string parameter (second string).

</pre>]]></Example>
</Entry>


</Entries>
<!-- ============================================================================================ -->
<!-- == END: ENTRIES ============================================================================ -->
<!-- ============================================================================================ -->
