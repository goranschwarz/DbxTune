/*******************************************************************************
 * Copyright (C) 2010-2025 Goran Schwarz
 * 
 * This file is part of DbxTune
 * DbxTune is a family of sub-products *Tune, hence the Dbx
 * Here are some of the tools: AseTune, IqTune, RsTune, RaxTune, HanaTune, 
 *          SqlServerTune, PostgresTune, MySqlTune, MariaDbTune, Db2Tune, ...
 * 
 * DbxTune is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * DbxTune is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DbxTune.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package com.dbxtune.sql.ddl.model;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;

public class Index
{
	public enum IndexType
	{
		OTHER, 
		CLUSTERED, 
		HASHED, 
		UNKNOWN 
	};

	protected Table     _table;
	
	protected String    _name;
	protected boolean   _isUnique;
	protected boolean   _isPrimaryKey;
	protected IndexType _type;
	protected String    _dbmsOptions;
	protected List<IndexColumn> _columns = new ArrayList<>();
	protected List<String>      _columnNames = new ArrayList<>();

	public String getIndexName()   { return _name; }
	public boolean isUnique()      { return _isUnique; }

	public List<IndexColumn> getIndexColumns() { return _columns; }

	/** Hold temporary structure so we can add columns via addColumnTmp() "out of column order" */
	private SortedMap<Integer, IndexColumn> _tmpAddColumns = new TreeMap<>();

	/** 
	 * Add column in a temporary fashion... (position do not have to be "in correct order")<br>
	 * Use addColumnTmpFinalize() to transfer the temporary structure to a permanent one 
	 */
	protected void addColumnTmp(int pos, String name, boolean isAscending)
	{
		_tmpAddColumns.put(pos, new IndexColumn(pos, name, isAscending));
	}
	/**
	 * Transfer '_tmpAddColumns' into '_columns'
	 */
	protected void addColumnTmpFinalize()
	{
		_columns     = new ArrayList<>(_tmpAddColumns.values());
		_columnNames = new ArrayList<>(_columns.size());
		for (IndexColumn icol : _columns)
			_columnNames.add(icol._name);
		
		if (_columnNames.equals(_table.getPkColumns()))
			_isPrimaryKey = true;
	}

	public boolean isPrimaryKey()
	{
		return _isPrimaryKey;
	}

	public List<String> getColumnNames()
	{
		return _columnNames;
	}

	public Table getParent() { return _table; }

	
	
	//-----------------------------------------------------------------------
	//-----------------------------------------------------------------------
	// Basic methods (generated by eclipse)
	//-----------------------------------------------------------------------
	//-----------------------------------------------------------------------
	@Override
	public int hashCode()
	{
		final int prime  = 31;
		int       result = 1;
		result = prime * result + ((_name == null) ? 0 : _name.hashCode());
		return result;
	}


	/**
	 * Uses member 'indexName' as the equality 
	 */
	@Override
	public boolean equals(Object obj)
	{
		if ( this == obj )
			return true;
		if ( obj == null )
			return false;
		if ( getClass() != obj.getClass() )
			return false;
		Index other = (Index) obj;
		if ( _name == null )
		{
			if ( other._name != null )
				return false;
		}
		else if ( !_name.equals(other._name) )
			return false;
		return true;
	}
}
