/*******************************************************************************
 * Copyright (C) 2010-2019 Goran Schwarz
 * 
 * This file is part of DbxTune
 * DbxTune is a family of sub-products *Tune, hence the Dbx
 * Here are some of the tools: AseTune, IqTune, RsTune, RaxTune, HanaTune, 
 *          SqlServerTune, PostgresTune, MySqlTune, MariaDbTune, Db2Tune, ...
 * 
 * DbxTune is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * DbxTune is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DbxTune.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package com.dbxtune.gui.swing;

import java.awt.BorderLayout;
import java.awt.Font;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;

import com.dbxtune.gui.swing.ModalSleep.SleepAbortCallback;

import net.miginfocom.swing.MigLayout;

/**
 * Test generated by: Claude
 */
public class ModalSleepTest 
extends JFrame
{
	private static final long serialVersionUID = 1L;

	private JTextArea    _log_txt;
	private JButton      _basicSleep_but;
	private JButton      _callbackSleep1_but;
	private JButton      _callbackSleep2_but;
	private JButton      _interrupt_but;
	private JButton      _staticSleep_but;
	private JButton      _clear_but;
	private JProgressBar _progress_bar;
	private ModalSleep   _mSleep;

	public ModalSleepTest()
	{
		setTitle("ModalSleep Test Program");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setLayout(new BorderLayout(10, 10));

		// Create log area
		_log_txt = new JTextArea(15, 50);
		_log_txt.setEditable(false);
		_log_txt.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
		JScrollPane scrollPane  = new JScrollPane(_log_txt);

		// Create button panel
//		JPanel buttonPanel = new JPanel(new GridLayout(6, 1, 5, 5));
		JPanel buttonPanel = new JPanel(new MigLayout());

		_basicSleep_but     = new JButton("Test Basic Sleep (10 seconds)");
		_callbackSleep1_but = new JButton("Test Callback Sleep (10 sec max, check every 500ms), abort after 5 sec");
		_callbackSleep2_but = new JButton("Test Callback Sleep (10 sec max, check every 500ms), no abort");
		_interrupt_but      = new JButton("Interrupt Current Sleep");
		_staticSleep_but    = new JButton("Test Static Sleep Method (10 seconds) -- Can NOT be interrupted");
		_clear_but          = new JButton("Clear Log");

		_interrupt_but.setEnabled(false);

//		buttonPanel.add(_basicSleep_but);
//		buttonPanel.add(_callbackSleep1_but);
//		buttonPanel.add(_callbackSleep2_but);
//		buttonPanel.add(_interrupt_but);
//		buttonPanel.add(_staticSleep_but);
//		buttonPanel.add(clearBtn);
		buttonPanel.add(_basicSleep_but,      "split");
		buttonPanel.add(_callbackSleep1_but,  "");
		buttonPanel.add(_callbackSleep2_but,  "wrap");
		buttonPanel.add(_staticSleep_but,     "wrap");
		buttonPanel.add(_interrupt_but,       "split");
		buttonPanel.add(_clear_but,           "");

		// Progress bar
		_progress_bar = new JProgressBar();
		_progress_bar.setStringPainted(true);
		_progress_bar.setString("Ready");

		// Add components
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(buttonPanel, BorderLayout.NORTH);
		topPanel.add(_progress_bar, BorderLayout.SOUTH);

		add(topPanel, BorderLayout.NORTH);
		add(scrollPane, BorderLayout.CENTER);

		// Button listeners
		_basicSleep_but     .addActionListener(e -> testBasicSleep());
		_callbackSleep1_but .addActionListener(e -> testCallbackSleep1());
		_callbackSleep2_but .addActionListener(e -> testCallbackSleep2());
		_interrupt_but      .addActionListener(e -> interruptSleep());
		_staticSleep_but    .addActionListener(e -> testStaticSleep());
		_clear_but          .addActionListener(e -> clear());

		pack();
		setLocationRelativeTo(null);

		log("ModalSleep Test Program Started");
		log("All operations run on EDT without blocking the UI");
		log("Try clicking buttons or moving the window during sleep!");
		log("---");
	}

	private void testBasicSleep()
	{
		disableButtons(true);
		log("\n[BASIC SLEEP TEST]");
		log("Starting 10-second sleep...");
		_progress_bar.setString("Sleeping...");
		_progress_bar.setValue(0);

		long start = System.currentTimeMillis();
		_mSleep = new ModalSleep(10_000);
		_mSleep.start();
		long elapsed = System.currentTimeMillis() - start;

		log("Sleep completed!");
		log("Total sleep time: " + _mSleep.getTotalSleepTime() + "ms");
		log("Actual elapsed: " + elapsed + "ms");
		log("Was interrupted: " + _mSleep.wasInterrupted());

		_progress_bar.setString("Ready");
		disableButtons(false);
		_mSleep = null;
		log("<<< END.method.testBasicSleep()");
	}

	private void testCallbackSleep1()
	{
		disableButtons(true);
		log("\n[CALLBACK SLEEP TEST]");
		log("Starting sleep (max 10 seconds, checking every 500ms)");
		log("Sleep will auto-abort after 5 seconds or 10 callbacks");
		_progress_bar.setString("Sleeping with callback...");
		_progress_bar.setValue(0);

		final int[] callbackCount = { 0 };

		long start = System.currentTimeMillis();
//		_mSleep = new ModalSleep(10000, 500, () -> 
//		{
//			callbackCount[0]++;
//			log("  Callback #" + callbackCount[0] + " - Still sleeping...");
//			_progress_bar.setString("Callback " + callbackCount[0] + "/10");
//
//			// Abort after 10 callbacks (5 seconds)
//			return callbackCount[0] >= 10;
//		});
		_mSleep = new ModalSleep(10000, 500, new SleepAbortCallback()
		{
			@Override
			public boolean abortSleepQuestion()
			{
				callbackCount[0]++;
				log("  Callback #" + callbackCount[0] + " - Still sleeping...");
				_progress_bar.setString("Callback " + callbackCount[0] + "/10");
				_progress_bar.setValue(_mSleep.getPercentWaitedTime());

				// Abort after 10 callbacks (5 seconds)
				return callbackCount[0] >= 10;
			}
		}); 
		_mSleep.start();

		long elapsed = System.currentTimeMillis() - start;

		log("Sleep ended!");
		log("Total sleep time: " + _mSleep.getTotalSleepTime() + "ms");
		log("Actual elapsed: " + elapsed + "ms");
		log("Callbacks executed: " + callbackCount[0]);
		log("Was interrupted: " + _mSleep.wasInterrupted());

		_progress_bar.setString("Ready");
		disableButtons(false);
		_mSleep = null;
		log("<<< END.method.testCallbackSleep1()");
	}

	private void testCallbackSleep2()
	{
		disableButtons(true);
		log("\n[CALLBACK SLEEP TEST]");
		log("Starting sleep (max 10 seconds, checking every 500ms), no abort...");
		_progress_bar.setString("Sleeping with callback...");
		_progress_bar.setValue(0);

		final int[] callbackCount = { 0 };

		long start = System.currentTimeMillis();
//		_mSleep = new ModalSleep(10000, 500, () -> 
//		{
//			callbackCount[0]++;
//			log("  Callback #" + callbackCount[0] + " - Still sleeping...");
//			_progress_bar.setString("Callback " + callbackCount[0] + "/10");
//
//			// Abort after 10 callbacks (5 seconds)
////			return callbackCount[0] >= 10;
//			return false;
//		});
		_mSleep = new ModalSleep(10000, 500, new SleepAbortCallback()
		{
			@Override
			public boolean abortSleepQuestion()
			{
				callbackCount[0]++;
				log("  Callback #" + callbackCount[0] + " - Still sleeping...");
				_progress_bar.setString("Callback " + callbackCount[0] + "/10");
				_progress_bar.setValue(_mSleep.getPercentWaitedTime());

				// Abort after 10 callbacks (5 seconds)
//				return callbackCount[0] >= 10;
				return false;
			}
		});
		_mSleep.start();
		

		long elapsed = System.currentTimeMillis() - start;

		log("Sleep ended!");
		log("Total sleep time: " + _mSleep.getTotalSleepTime() + "ms");
		log("Actual elapsed: " + elapsed + "ms");
		log("Callbacks executed: " + callbackCount[0]);
		log("Was interrupted: " + _mSleep.wasInterrupted());

		_progress_bar.setString("Ready");
		disableButtons(false);
		_mSleep = null;
		log("<<< END.method.testCallbackSleep2()");
	}

	private void interruptSleep()
	{
		log("--- Calling: interruptSleep(): _mSleep=" + _mSleep);
		if ( _mSleep != null )
		{
			log(">>> INTERRUPTING SLEEP <<<");
			_mSleep.interrupt();
		}
	}

	private void testStaticSleep()
	{
		disableButtons(true);
		log("\n[STATIC SLEEP TEST]");
		log("Using static ModalSleep.sleep(10_000)...");
		_progress_bar.setString("Static sleep...");
		_progress_bar.setValue(0);

		long start = System.currentTimeMillis();
		ModalSleep.sleep(10_000);
		long elapsed = System.currentTimeMillis() - start;

		log("Static sleep completed!");
		log("Elapsed time: " + elapsed + "ms");

		_progress_bar.setString("Ready");
		disableButtons(false);
		log("<<< END.method.testStaticSleep()");
	}
	
	private void clear()
	{
		_progress_bar.setValue(0);
		_progress_bar.setString("");
		_log_txt.setText("");		
	}

	private void disableButtons(boolean sleeping)
	{
		_basicSleep_but    .setEnabled(!sleeping);
		_callbackSleep1_but.setEnabled(!sleeping);
		_callbackSleep2_but.setEnabled(!sleeping);
		_staticSleep_but   .setEnabled(!sleeping);
		_interrupt_but     .setEnabled(sleeping);
	}

	private void log(String message)
	{
		_log_txt.append(message + "\n");
		_log_txt.setCaretPosition(_log_txt.getDocument().getLength());
	}

	public static void main(String[] args)
	{
		try {
			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		} catch (Exception e) {
			e.printStackTrace();
		}

		SwingUtilities.invokeLater(() -> {
			ModalSleepTest frame = new ModalSleepTest();
			frame.setVisible(true);
		});
	}
}
